{"meta":{"title":"漠北空城","subtitle":"听海观潮","description":"","author":"Yue Chang","url":"http://yuechang.github.io"},"pages":[{"title":"","date":"2016-05-12T11:10:49.400Z","updated":"2016-05-12T11:10:43.403Z","comments":true,"path":"README.html","permalink":"http://yuechang.github.io/README.html","excerpt":"","text":""},{"title":"","date":"2016-01-23T09:38:23.596Z","updated":"2014-12-24T15:19:40.000Z","comments":true,"path":"404.html","permalink":"http://yuechang.github.io/404.html","excerpt":"","text":"404 body { background-color: #FFF; font-family: 'Open Sans', sans-serif; font-size: 14px; color: #3c3c3c; } .demo{width:600px;margin:0 auto;} .demo p:first-child { text-align: center; font-family: cursive; font-size: 150px; font-weight: bold; line-height: 100px; letter-spacing: 5px; color: #fff; } .demo p:first-child span { cursor: pointer; text-shadow: 0px 0px 2px #686868, 0px 1px 1px #ddd, 0px 2px 1px #d6d6d6, 0px 3px 1px #ccc, 0px 4px 1px #c5c5c5, 0px 5px 1px #c1c1c1, 0px 6px 1px #bbb, 0px 7px 1px #777, 0px 8px 3px rgba(100, 100, 100, 0.4), 0px 9px 5px rgba(100, 100, 100, 0.1), 0px 10px 7px rgba(100, 100, 100, 0.15), 0px 11px 9px rgba(100, 100, 100, 0.2), 0px 12px 11px rgba(100, 100, 100, 0.25), 0px 13px 15px rgba(100, 100, 100, 0.3); -webkit-transition: all .1s linear; transition: all .1s linear; } .demo p:first-child span:hover { text-shadow: 0px 0px 2px #686868, 0px 1px 1px #fff, 0px 2px 1px #fff, 0px 3px 1px #fff, 0px 4px 1px #fff, 0px 5px 1px #fff, 0px 6px 1px #fff, 0px 7px 1px #777, 0px 8px 3px #fff, 0px 9px 5px #fff, 0px 10px 7px #fff, 0px 11px 9px #fff, 0px 12px 11px #fff, 0px 13px 15px #fff; -webkit-transition: all .1s linear; transition: all .1s linear; } .demo p:not(:first-child) { text-align: center; color: #666; font-family: cursive; font-size: 20px; text-shadow: 0 1px 0 #fff; letter-spacing: 1px; line-height: 2em; margin-top: -50px; } 404 该页面不存在(´･ω･`) 返回首页"},{"title":"","date":"2016-01-23T09:38:23.596Z","updated":"2015-11-03T07:40:46.000Z","comments":true,"path":"about.html","permalink":"http://yuechang.github.io/about.html","excerpt":"","text":"About me About me 生于20世纪90年代，真名 Yue Chang 本科在读是软件工程，目前是一个苦逼程序猿，未来的系统昏析师。 contact email: yuechang5@sina.cn qq : 957513516"},{"title":"","date":"2016-01-23T09:38:23.596Z","updated":"2015-12-29T15:07:50.000Z","comments":true,"path":"content.html","permalink":"http://yuechang.github.io/content.html","excerpt":"","text":"联系我们 body { background-color: #FFF; font-family: 'Open Sans', sans-serif; font-size: 14px; color: #3c3c3c; } 联系我们 返回首页"},{"title":"tags","date":"2017-01-20T09:42:00.000Z","updated":"2017-01-20T09:43:33.064Z","comments":false,"path":"tags/index.html","permalink":"http://yuechang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"spring-AOP-配置","slug":"spring-AOP-配置","date":"2017-11-28T10:00:10.000Z","updated":"2017-11-28T14:02:41.027Z","comments":true,"path":"2017/11/28/spring-AOP-配置/","link":"","permalink":"http://yuechang.github.io/2017/11/28/spring-AOP-配置/","excerpt":"","text":"spring-AOP-配置spring-AOP-配置 1、步骤1.1、创建一个接口PersonDao1.2、创建一个目标类PersonDaoImpl1.3、创建一个事务Transaction1.4、把目标类和事务放入到spring容器中1.5、进行aop的配置1.5.1、引入aop的命名空间123xmlns:aop=\"http://www.springframework.org/schema/aop\"http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd 1.5.2、把PersonDao和Transaction放入到spring容器中12&lt;bean id=\"personDao\" class=\"...\"&gt;&lt;/bean&gt;&lt;bean id=\"transaction\" class=\"...\"&gt;&lt;/bean&gt; 1.5.3、进行aop的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;aop:config&gt; &lt;!-- 切入点表达式 id为该切面点表达式的唯一标示 --&gt; &lt;aop:pointcut expression=\"execution(* com.yc.spring.PersonDaoImpl.*(..))\" id=\"perform\"/&gt; &lt;!-- 一个aspect代表一个切面 --&gt; &lt;aop:aspect ref=\"transaction\"&gt; &lt;!-- 前置通知： 1、在目标方法执行之前执行； 2、在前置通知中有一个参数：JoinPoint，该参数可以获取目标方法的一些信息； --&gt; &lt;aop:before method=\"beginTransaction\" pointcut-ref=\"perform\"/&gt; &lt;!-- 后置通知 1、在目标方法执行之后； 2、如果目标方法遇到异常，则后置通知将不在执行； 3、方法中也有两个参数： JoinPoint： Object：该参数的名称要与returing配置的参数名称一致 4、能够获取目标方法的返回值； --&gt; &lt;aop:after-returning method=\"commit\" pointcut-ref=\"perform\" returning=\"obj\"/&gt; &lt;!-- 最终通知 无论目标方法是否遇到异常，都会执行 --&gt; &lt;aop:after method=\"finallyMethod\" pointcut-ref=\"perform\"/&gt; &lt;!-- 异常通知 1、获取目标方法获取的异常信息 2、throwing=\"ex\",异常通知中的异常的名称必须是ex --&gt; &lt;aop:after-throwing method=\"throwingMethod\" pointcut-ref=\"perform\" throwing=\"ex\"/&gt; &lt;!-- 环绕通知 1、控制目标方法的执行； 2、该方法中有一个ProceedingJoinPoint参数； 3、该参数的proceed()方法调用的是目标方法，,如果该方法不调用，则目标方法不会执行； 4、可以从ProceedingJoinPoint中得到目标方法的一些信息； 5、需要返回时，环绕通知方法也需要返回 6、环绕通知和前置通知/后置通知一般不同时存在 7、前置通知和后置通知不能控制目标方法的执行； --&gt; &lt;aop:around method=\"aroundMethod\" pointcut-ref=\"perform\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 2、原理： 1、启动spring容器，把personDao和transaction实例化 2、当spring容器解析到aop:config配置的时候，会解析切入点表达式 3、把切入点表达式解析出来以后，和spring容器中的bean做匹配，如果匹配成功，则为该bean创建代理对象; 4、代理对象的方法的创建过程就把通知和目标方法结合在一起了 5、当在客户端执行context.getBean时，先检查跟bean是否有代理对象，如果有代理对象，则返回代理对象;如果没有代理对象，则返回对象本身注意：如果切入点表达式在spring容器中没有找到匹配的对象，则会报错 3、切入点配置说明下面是spring切入点的配置说明：1execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)throws-pattern?) 直接看的话，还是不是很好理解通过一个方法声明的来对比说明一下：1public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException 修饰符类型 返回值类型 声明类型 方法名 参数类型 异常类型 modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern param-pattern throws-pattern? public void java.lang.Object wait long throws java.lang.InterruptedException 切入点配置举例：execution (public (..) ) : 表示任意公共方法execution ( set(..) ) : 表示以set开头的任意方法execution ( com.xyz.service.AccountService.(..) ) : 表示com.xyz.service.AccountService类中的所有方法execution ( com.xyz.service..(..) ) ：表示com.xyz.service包下的所有的类的所有的方法execution ( com.xyz.service...(..) ) ：表示com.xyz.service包下及其子包下的所有的类的所有的方法","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring-AOP简介","slug":"spring-AOP简介","date":"2017-11-28T09:00:10.000Z","updated":"2017-11-28T09:20:30.432Z","comments":true,"path":"2017/11/28/spring-AOP简介/","link":"","permalink":"http://yuechang.github.io/2017/11/28/spring-AOP简介/","excerpt":"","text":"spring-AOP简介spring面向切面编程 1、切面事务、日志、安全性框架、权限等都是切面 2、通知通知就是切面中的方法1234567891011// Transaction类为一个切面public class Transaction &#123; // beginTransaction()方法为一个通知 public void beginTransaction()&#123; System.out.println(\"begin transaction\"); &#125; // commit()方法为另一个通知 public void commit()&#123; System.out.println(\"commit\"); &#125;&#125; 3、切入点12345678910111213if(method.getName().contains(\"save\") ||method.getName().contains(\"update\") ||method.getName().contains(\"delete\"))&#123; //1、开启事务 this.transaction.beginTransaction(); //2、完成目标方法 obj = method.invoke(this.target, args); //3、事务的提交 this.transaction.commit();&#125;else&#123; //2、完成目标方法 obj = method.invoke(this.target, args);&#125; 在上面的代码中if语句块的内容就是切入点，只有满足了切入点以后，才能让通知和目标方法结合在一起 4、连接点代理对象调用哪个方法，该方法就称为连接点（在程序执行过程中某一个特定的点） 5、织入：形成代理对象方法体的过程，一个动作 6、说明： 1、代理对象的方法=通知+目标方法 2、除了目标方法以外的内容都可以看做切面中的通知（比如目标方法有CRUD，除了CRUD之外的都是通知，如开启事务、事务提交及事务回滚等） 3、连接点代表了一个方法，在客户端被调用的一个方法（这个方法目标方法和代理对象中都存在） 4、通知就是切面中的一个方法 5、在开发的过程中，通知和目标方法完全是松耦合的","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring-IOC-DI的意义","slug":"spring-IOC-DI的意义","date":"2017-11-26T13:30:10.000Z","updated":"2017-11-26T13:21:41.453Z","comments":true,"path":"2017/11/26/spring-IOC-DI的意义/","link":"","permalink":"http://yuechang.github.io/2017/11/26/spring-IOC-DI的意义/","excerpt":"","text":"spring-IOC-DI的意义通过做一个文档管理系统来展示spring-IOC-DI的意义 1、一般方式步骤如下： 1、建立一个接口Document，增加readDocument()和writeDocument()方法 2、建立一个类WordDocument，实现Document接口，以及readDocument()和writeDocument()方法 3、建立ExcelDocument,PDFDocument，同样实现Document接口 4、做一个管理类DocumentManager 5、客户端1234567891011121314public class DocumentTest &#123; @Test public void test()&#123; /** * 1、创建一个具体的文档对象 * 2、创建DocumentManager对象 * 3、调用read和 write方法 */ Document document = new WordDocument(); DocumentManager documentManager = new DocumentManager(document); documentManager.read(); documentManager.write(); &#125;&#125; 2、用spring容器方式步骤如下： 1、建立一个接口Document，增加readDocument()和writeDocument()方法 2、建立一个类WordDocument，实现Document接口，以及readDocument()和writeDocument()方法 3、建立ExcelDocument,PDFDocument，同样实现Document接口 4、配置文件 12345678910&lt;bean id=\"wordDocument\" class=\"...\"&gt;&lt;/bean&gt;&lt;bean id=\"excelDocument\" class=\"...\"&gt;&lt;/bean&gt;&lt;bean id=\"pdfDocument\" class=\"...\"&gt;&lt;/bean&gt;&lt;bean id=\"documentManager\" class=\"...\"&gt; &lt;!-- 该属性是一个接口 --&gt; &lt;property name=\"document\"&gt; &lt;!-- 把这个对象给接口赋值 --&gt; &lt;ref bean=\"excelDocument\"/&gt; &lt;/property&gt;&lt;/bean&gt; 5、客户端 123456789101112/** * 客户端完全不需要关系具体的实现类是哪个 */@Testpublic void test_SPring()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DocumentManager documentManager = (DocumentManager)context.getBean(\"documentManager\"); documentManager.read(); documentManager.write();&#125; 在DocumentManager中，document接口的装配过程是由spring容器来完成的，客户端根本不知道这个过程 3、结论通过普通的方式，在客户端中暴露了实现类，只是半面向接口编程；通过spring的方式，在客户端只需要调用documentManager的API编程就可以完成调用，完全的做到了面向接口编程","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring 类扫描","slug":"spring 类扫描","date":"2017-11-26T12:30:10.000Z","updated":"2017-11-26T12:26:27.135Z","comments":true,"path":"2017/11/26/spring 类扫描/","link":"","permalink":"http://yuechang.github.io/2017/11/26/spring 类扫描/","excerpt":"","text":"spring 类扫描1、启动spring容器，spring容器会解析到以下配置1&lt;context:component-scan base-package=\"...\"&gt;&lt;/context:component-scan&gt; 2、spring容器会在base-package包及子包中扫描所有的类3、检查这些类中是否含有@Component注解如果含有，则进行解析，形式1：1234@Componentpublic class Person&#123;&#125; 这种形式的将会解析成：1&lt;bean id=\"person\" class=\"...\"&gt; 形式2：1234@Component(\"aa\")public class Person&#123;&#125; 这种形式的将会解析成：1&lt;bean id=\"aa\" class=\"...\"&gt; 4、会查找spring容器中的bean,看哪些bean中有@Resource注解，并且按照该注解的规则给属性赋值5、优缺点 这样的写法很简单，但是效率比较低扫描两次 扫描base-package以及子包所有的类，看哪些类上面加了注解(Component/Service等) 扫描哪些类上加了Rescource/Autowired注解","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring DI-注解注入","slug":"spring-DI-注解注入","date":"2017-11-25T11:30:10.000Z","updated":"2017-11-25T10:48:14.414Z","comments":true,"path":"2017/11/25/spring-DI-注解注入/","link":"","permalink":"http://yuechang.github.io/2017/11/25/spring-DI-注解注入/","excerpt":"","text":"spring DI-注解注入用注解实现属性注入 1、步骤：1.1、创建Student类和Person类12345678public class Person &#123; @Resource private Student student; public void say()&#123; this.student.say(); &#125;&#125; 1.2、把Person和Student放入到spring容器中12&lt;bean id=\"student\" class=\"...\"&gt;&lt;/bean&gt;&lt;bean id=\"person\" class=\"...\"&gt;&lt;/bean&gt; 1.3、启动依赖注入的注解解析器1&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; 注意:基本类型不能用注解完成注入 2、原理：2.1、当启动spring容器的时候创建了person和student两个对象2.2、加载配置文件是否含有context:annotation-config当spring容器解析到context:annotation-config&lt;/context:annotation-config&gt;spring容器会在纳入spring管理范围的bean查找； 2.3、查找这些bean的方法或者属性上是否含有Resource注解2.4、当存在Resource注解则查看该注解的属性name的值： 如果name的值为””,则会按照该注解所在的属性的名称和spring容器中的ID做匹配，如果匹配成功，则赋值；如果匹配不成功，则按照类型进行匹配,则赋值; 如果类型再匹配不成功，则报错； 如果name的属性值不为””,则按照name的属性的值和spring容器中的ID匹配，成功，则赋值，不成功，则报错 3、xml与注解区别 xml效果比较高，写法比较复杂 注解效率比较低，但是写法比较简单 因为注解可能需要查找spring容器中定义的所有bean。 4、依赖注入的注解 @Resource(name=”student”) 见上面 @Autowired 按照类型进行匹配 @Qualifier(“student”) 按照”student”与spring中的ID进行匹配 @Resource = @Autowired + @Qualifier(“student”) @Autowired + @Qualifier(“student”)组合使用","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring DI-构造注入","slug":"spring-DI-构造注入","date":"2017-11-25T10:30:10.000Z","updated":"2017-11-26T06:29:46.853Z","comments":true,"path":"2017/11/25/spring-DI-构造注入/","link":"","permalink":"http://yuechang.github.io/2017/11/25/spring-DI-构造注入/","excerpt":"","text":"spring DI-构造注入1、需要注意的地方1&lt;bean id=\"student\" class=\"...\"&gt;&lt;/bean&gt; 如果一个bean的配置中没有指名constructor-arg，则用默认的构造器创建对象 2、利用构造器给属性赋值&lt;bean id=\"person\" class=\"...\"&gt; &lt;constructor-arg index=\"0\" value=\"aaa\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"1\" ref=\"student\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 一个bean只能配置一个构造器，spring容器会利用该构造器为这个bean创建对象。 一个bean的最标准的写法： 写带参数构造函数时，同时加上默认构造函数 加上对应的setter和getter方法好处：在配置文件中可以进行很灵活的配置","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"注解","slug":"注解","date":"2017-11-22T14:45:10.000Z","updated":"2017-11-22T14:57:33.471Z","comments":true,"path":"2017/11/22/注解/","link":"","permalink":"http://yuechang.github.io/2017/11/22/注解/","excerpt":"","text":"注解1、起一个标志的作用2、注解不能单独存在3、注解使用的位置123456789101112131415161718public enum ElementType &#123; // 类与接口 TYPE, // 属性 FIELD, // 方法 METHOD, // 参数 PARAMETER, // 构造器 CONSTRUCTOR, // 局部变量 LOCAL_VARIABLE, // 注解类型Annotation type declaration ANNOTATION_TYPE, // 包类型 Package declaration PACKAGE&#125; 4、注解起作用的范围有下面范围： source 源码级别 classes 字节码级别 runtime 运行时级别（经常用的范围） 5、自定义注解// 注解使用的位置 @Target(ElementType.TYPE) // 起作用的范围 @Retention(RetentionPolicy.RUNTIME) // 能出现在帮助文档中 @Documented public @interface ClassAnnotation { String name() default \"\"; } 说明： 1、该注解只能用于类上 @Target(ElementType.TYPE) 2、该注解的范围：java,class,runtime都可以 3、该注解有一个属性name,为String类型，默认值为”” 要想获得类上面的注解，先获得类(Class)；要想获得方法上面的注解，先获得方法(Method) 方法名 用法 Annotation getAnnotation(Class annotationType) 获取注解在其上的annotationType Annotation[] getAnnotations() 获取所有注解 isAnnotationPresent(Class annotationType) 判断当前元素是否被annotationType注解 Annotation[] getDeclareAnnotations() 与getAnnotations() 类似，但是不包括父类中被Inherited修饰的注解","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring DI-setter注入","slug":"spring-DI-setter注入","date":"2017-11-21T14:30:10.000Z","updated":"2017-11-21T15:28:07.351Z","comments":true,"path":"2017/11/21/spring-DI-setter注入/","link":"","permalink":"http://yuechang.github.io/2017/11/21/spring-DI-setter注入/","excerpt":"","text":"spring DI-setter注入1、对象定义Student类和Person类： 123456789101112public class Student&#123;&#125; public class Person&#123; private Long pid; private String name; private Student student; private List list; private Set set; private Map map; private Properties properties;&#125; 2、装置属性配置装载属性配置如下： 基本属性 list set map object1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;bean id=\"student\" class=\"...\" scope=\"prototype\"&gt;&lt;/bean&gt;&lt;bean id=\"person\" class=\"...\"&gt; &lt;!-- 是用来描述Person的属性 name为属性的名称 value就给name的属性赋值 基本属性可以这样赋值： String类型和基本类型(数据类型) ref是给引用类型赋值的 &lt;property name=\"student\" ref=\"student\"/&gt; &lt;property name=\"student\"&gt; &lt;ref bean=\"student\"/&gt; &lt;/property&gt; --&gt; &lt;property name=\"pid\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"王二麻子\"&gt;&lt;/property&gt; &lt;property name=\"student\"&gt; &lt;ref bean=\"student\"/&gt; &lt;/property&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;list1&lt;/value&gt; &lt;value&gt;list2&lt;/value&gt; &lt;ref bean=\"student\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;set1&lt;/value&gt; &lt;value&gt;set2&lt;/value&gt; &lt;ref bean=\"student\"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"map1\"&gt; &lt;value&gt;map1&lt;/value&gt; &lt;/entry&gt; &lt;entry key=\"map2\"&gt; &lt;ref bean=\"student\"/&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"p1\"&gt;afd&lt;/prop&gt; &lt;prop key=\"p2\"&gt;p2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 注意：如果在student对象scope对象配置为prototype，在student类的构造方法中写入输出student语句，将会打印出4个student。第一个因为有ref引用，spring将对象创建提前了，创建了一个student对象；后面三个是一个ref创建一个student对象；","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring DI简介","slug":"spring-DI简介","date":"2017-11-21T14:30:10.000Z","updated":"2017-11-21T15:13:28.818Z","comments":true,"path":"2017/11/21/spring-DI简介/","link":"","permalink":"http://yuechang.github.io/2017/11/21/spring-DI简介/","excerpt":"","text":"spring DI简介DI:依赖注入概念：给属性赋值 1、调用set方法 基础类型 引用类型 2、调用构造器 3、利用注解的形式 public class Student{ } public class Person{ private Long pid; private String name; private Student student; private List list; private Set set; private Map map; private Properties properties; } 步骤： 1、创建一个Student类 2、创建一个Person类 3、创建一个spring的配置文件，把student类和person类 放入到spring容器中 4、装配各个属性 执行流程： 1、启动spring容器 2、创建依赖对象(Student对象) 3、创建Person对象 4、给person对象中的属性进行装配的操作 注意： 如果把Student的配置方式改成scope=”prototype”, 因为其他的类的创建和属性的装配的过程全部发生在spring容器启动的时候，所以Student对象的创建被提前了 ，但是还是用一次即创建一次对象","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring IOC创建对象配置初始化方法和销毁方法","slug":"spring-IOC创建对象配置初始化方法和销毁方法","date":"2017-11-21T14:22:10.000Z","updated":"2017-11-21T14:17:34.599Z","comments":true,"path":"2017/11/21/spring-IOC创建对象配置初始化方法和销毁方法/","link":"","permalink":"http://yuechang.github.io/2017/11/21/spring-IOC创建对象配置初始化方法和销毁方法/","excerpt":"","text":"spring IOC创建对象配置初始化方法和销毁方法1、创建一个类public class HelloWorld { public HelloWorld(){ System.out.println(\"hello world\"); } public void init(){ System.out.println(\"init\"); } public void destroy(){ System.out.println(\"destroy\"); } public void hello(){ System.out.println(\"hello\"); } } 2、spring配置文件中&lt;bean id=\"helloWorld\" class=\"com.ithiema07.spring.ioc.initdestroy.HelloWorld\" init-method=\"init\" destroy-method=\"destroy\"&gt;&lt;/bean&gt; 3、执行顺序： 1、启动spring容器 2、创建对象 3、执行init方法 该方法是由spring容器内部调用的 4、执行destroy方法 该方法是由spring容器内部调用的 前提：在spring容器关闭的时候执行,仅单例 注意点：如果一个bean是多例，则spring容器不负责销毁 4、到目前为止spring容器的执行顺序： 1、启动spring容器 2、如果该bean为单例，并且lazy-init为”default/false”,这个时候为该bean创建对象 3、执行该bean的init方法 4、在客户端利用context.getBean得到该对象 如果是多例，或者lazy-init为”true”,则在这步创建对象 5、在客户端对象调用方法 6、当spring容器关闭的时候，如果该bean是单例，则调用destroy方法","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring IOC产生对象的时机","slug":"spring-IOC产生对象的时机","date":"2017-11-20T13:22:10.000Z","updated":"2017-11-21T13:33:18.547Z","comments":true,"path":"2017/11/20/spring-IOC产生对象的时机/","link":"","permalink":"http://yuechang.github.io/2017/11/20/spring-IOC产生对象的时机/","excerpt":"","text":"spring IOC产生对象的时机1、配置文件如下：12&lt;bean id=\"helloWorld\" class=\"...\" &gt;&lt;/bean&gt;&lt;bean id=\"helloWorld2\" class=\"...\" &gt;&lt;/bean&gt; 说明：1、只要声明一个bean，spring容器就会为之创建对象，不管class是否相同2、在默认情况下，在启动spring容器的时候创建对象3、把service层和dao层所有的类放入spring容器中，在启动spring容器的时候创建对象4、可以过早的检查发现错误5、缺点：如果该类中有属性，并且属性为一个集合，那么在创建对象的时候，集合中如果有数据了，那么该数据会过早的加入到内存中 为了避免上述情况的发生，尽量把数据放在局部变量中（通过代理来做，需要的时候再加载）12345678910@Componentpublic class SystemProperties&#123; private Properties properties; @PostConstruct public void initProperties()&#123; properties = ...; &#125;&#125; 系统初始化的时候，加载数据库系统配置文件到Properties类中 2、配置延迟加载：1&lt;bean id=\"helloWorld\" class=\"...\" lazy-init=\"true\"&gt;&lt;/bean&gt; default:默认=否false：否，spring启动时创建对象ture：是，调用时才创建对象 在多例的情况下，不论是否设置lazy-init，都是在调用的时候才创建对象1&lt;bean id=\"helloWorld\" class=\"...\" scope=\"prototype\" lazy-init=\"ture\"&gt;&lt;/bean&gt;","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring IOC产生对象的生命周期","slug":"spring-IOC产生对象的生命周期","date":"2017-11-20T13:22:10.000Z","updated":"2017-11-20T14:28:34.137Z","comments":true,"path":"2017/11/20/spring-IOC产生对象的生命周期/","link":"","permalink":"http://yuechang.github.io/2017/11/20/spring-IOC产生对象的生命周期/","excerpt":"","text":"spring IOC产生对象的生命周期1、HelloWorld在默认的配置情况下是单例的。验证过程：1、创建HelloWorld类 2、把该类放入到spring容器中 3、启动调用 将来在做项目的时候，会把service层和dao层所有的类放入到spring容器中，service层所有的类和dao层所有的类都是单例的，不能一个对象放在属性上（因为是共享的） 2、多例，需要配置scope1&lt;bean id=\"helloWorld\" class=\"...\" scope=\"prototype\"&gt;&lt;/bean&gt; singleton：单例(默认)prototype：多例request：每一次HTTP请求产生一个新的bean，同时该bean仅在当前HTTP request内有效session：每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效global session：每一次HTTP请求都会产生一个新的bean，同时该bean全局HTTP session内有效 singleton：返回单例的对象，只会初始化一次 prototype：每次都会new一个对象返回，也就是多例的，另外对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个prototype bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。 清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责。（让Spring容器释放被singleton作用域bean占用资源的一种可行方式是，通过使用 bean的后置处理器，该处理器持有要被清除的bean的引用。） singleton和prototype二者选择的原则：有状态的bean都使用Prototype作用域，而对无状态的bean则应该使用singleton作用域。 因为stuts2中的action是多例的，所以将来struts2中的action要放入spring容器中也是多例的","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring IOC创建对象的方法","slug":"spring-IOC创建对象的方法","date":"2017-09-26T05:22:10.000Z","updated":"2017-11-21T13:42:28.163Z","comments":true,"path":"2017/09/26/spring-IOC创建对象的方法/","link":"","permalink":"http://yuechang.github.io/2017/09/26/spring-IOC创建对象的方法/","excerpt":"","text":"spring IOC创建对象的方法1、默认的构造器函数在默认的配置情况下，spring容器是利用默认的构造器给类创建对象的 2、静态工厂模式123456789101112// 步骤：// 1、静态工厂public class HelloWorldFactory &#123; public static HelloWorld getInstance()&#123; return new HelloWorld(); &#125;&#125;// 2、提供一个HelloWorld类// 3、在spring的配置文件中进行配置&lt;bean id=\"helloWorldCreateByStaticFactory\" class=\"com.yc.spring.ioc.HelloWorldFactory\" factory-method=\"getInstance\" /&gt; spring容器做的事：调用静态工厂方法创建对象，但是创建对象的方法的代码在工厂方法中 3、实例工厂模式12345678910111213141516171819// 步骤// 1、创建实例工厂类public class HelloWorldFactory &#123; public HelloWorld getInstance()&#123; return new HelloWorld(); &#125;&#125;// 2、提供一个HelloWorld类// 3、在spring的配置文件中进行配置 &lt;!-- 配置实例工厂--&gt; &lt;bean id=\"helloWorldFactory\" class=\"com.yc.spring.ioc.HelloWorld2Factory\" /&gt; &lt;!-- 配置helloWorld3 factory-bean：指向了实例工厂 factory-method:指向了实例的工厂方法 --&gt; &lt;bean id=\"helloWorld3\" factory-bean=\"helloWorldFactory\" factory-method=\"getInstance\"/&gt;","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"spring IOC创建对象","slug":"spring-IOC创建对象","date":"2017-09-26T02:08:18.000Z","updated":"2017-11-21T13:27:38.246Z","comments":true,"path":"2017/09/26/spring-IOC创建对象/","link":"","permalink":"http://yuechang.github.io/2017/09/26/spring-IOC创建对象/","excerpt":"","text":"1、简介spring 是一个非常活跃的开源框架，它是一个基于core来架构多层Java EE系统的框架，它的主要目地是简化企业开发spring以一种非侵入式的方式来管理你的代码，spring提倡”最少侵入”，这也就意味着你可以适当的时候安装或卸载spring spring的控制反转(IOC)：把对象的创建、初始化/销毁等工作交给spring容器来做，由spring容器控制对象的生命周期。意义：对象的创建交给spring容器来做，对于程序员来说，不用操心该对象是怎么样创建出来的。 2、创建对象2.1、一般方式创建对象1、创建一个HelloWorld类2、把java类编译成class文件3、把class文件加载到jvm中4、运行，调用方法 通过new的方式创建对象并调用对象的方法 2.2、spring方式创建对象1、创建一个HelloWorld类2、以配置文件的形式吧HelloWorld类放入spring容器中3、启动spring容器4、从spring容器中把对象提取出来5、对象调用方法 首先pom.xml文件中引入以下依赖：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt; 创建HelloWorld类，里面定义一个hello()方法，打印出hello 编写applicationContext.xml文件12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- 把一个类放入到spring容器中，该类为一个bean beans说明可以配置多个类 --&gt; &lt;!-- bean代表helloWorld id 标示符 书写规范：类的第一个字母变成小写 class 表示类的全名 --&gt; &lt;bean id=\"helloWorld\" class=\"com.yc.spring.ioc.HelloWorld\"&gt;&lt;/bean&gt; &lt;!-- 别名alias与id一样唯一标识一个bean --&gt; &lt;alias name=\"helloWorld\" alias=\"helloworldAliasName\"/&gt;&lt;/beans&gt; 测试类编写，并成功输出结果12345678910@SuppressWarnings(\"resource\")@Testpublic void testHelloWorld()&#123; // 启动了spring容器，创建对象 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\"); // 获取helloWorld bean 实例 HelloWorld instance = (HelloWorld) applicationContext.getBean(\"helloWorld\"); instance.hello();&#125; ApplicationContext主要结构：ApplicationContext:容器顶级接口 ConfigurableApplicationContext：可配置spring容器 ClassPathXmlApplicationContext:从claspath环境中加载配置文件 FileSystemXmlApplicationContext:从文件系统中加载配置文件 WebApplicationContext：web spring容器","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yuechang.github.io/tags/spring/"}]},{"title":"Spring boot 整合Dubbo","slug":"Spring-boot整合Dubbo","date":"2017-05-22T14:24:08.000Z","updated":"2017-06-09T02:24:05.828Z","comments":true,"path":"2017/05/22/Spring-boot整合Dubbo/","link":"","permalink":"http://yuechang.github.io/2017/05/22/Spring-boot整合Dubbo/","excerpt":"","text":"Spring boot 整合Dubbo Spring boot 整合Dubbo 环境 Spring boot：1.5.3.RELEASE zookeeper：3.4.10 dubbo：2.5.3 123456789101112- +----------------+ |dubbo-interface | +----------------+ | | +------++------+------++------+ | | | | +----------------+ +----------------+| dubbo-provider | | dubbo-comsumer |+----------------+ +----------------+ dubbo-interface：定义接口 dubbo-provider：提供服务 dubbo-cosumer：消费服务 1、接口定义代码12345package com.hhly.dubbo.service;public interface HelloProvider &#123; public String sayHello(String name);&#125; 2、服务提供者2.1、服务提供者配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.hhly.dubbo.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import com.alibaba.dubbo.config.ApplicationConfig;import com.alibaba.dubbo.config.ProtocolConfig;import com.alibaba.dubbo.config.ProviderConfig;import com.alibaba.dubbo.config.RegistryConfig;import com.alibaba.dubbo.config.spring.AnnotationBean;import com.alibaba.dubbo.rpc.Exporter;@Configuration@ConditionalOnClass(Exporter.class)@PropertySource(value = \"classpath:/dubbo.properties\")public class DubboConfiguration &#123; @Value(\"$&#123;dubbo.application.name&#125;\") private String applicationName; @Value(\"$&#123;dubbo.registr.protocol&#125;\") private String protocol; @Value(\"$&#123;dubbo.registry.address&#125;\") private String registryAddress; @Value(\"$&#123;dubbo.protocol.name&#125;\") private String protocolName; @Value(\"$&#123;dubbo.protocol.port&#125;\") private int protocolPort; @Value(\"$&#123;dubbo.provider.timeout&#125;\") private int timeout; @Value(\"$&#123;dubbo.provider.retries&#125;\") private int retries; @Value(\"$&#123;dubbo.provider.delay&#125;\") private int delay; /** * 设置dubbo扫描包 * * @param packageName * @return */ @Bean public static AnnotationBean annotationBean(@Value(\"$&#123;dubbo.annotation.package&#125;\") String packageName) &#123; AnnotationBean annotationBean = new AnnotationBean(); annotationBean.setPackage(packageName); return annotationBean; &#125; /** * 注入dubbo上下文 * * @return */ @Bean public ApplicationConfig applicationConfig() &#123; // 当前应用配置 ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(this.applicationName); return applicationConfig; &#125; /** * 注入dubbo注册中心配置,基于zookeeper * * @return */ @Bean public RegistryConfig registryConfig() &#123; // 连接注册中心配置 RegistryConfig registry = new RegistryConfig(); registry.setProtocol(protocol); registry.setAddress(registryAddress); return registry; &#125; /** * 默认基于dubbo协议提供服务 * * @return */ @Bean public ProtocolConfig protocolConfig() &#123; // 服务提供者协议配置 ProtocolConfig protocolConfig = new ProtocolConfig(); protocolConfig.setName(protocolName); protocolConfig.setPort(protocolPort); protocolConfig.setThreads(200); //System.out.println(\"默认protocolConfig：\" + protocolConfig.hashCode()); return protocolConfig; &#125; /** * dubbo服务提供 * * @param applicationConfig * @param registryConfig * @param protocolConfig * @return */ @Bean(name = \"myProvider\") public ProviderConfig providerConfig(ApplicationConfig applicationConfig, RegistryConfig registryConfig, ProtocolConfig protocolConfig) &#123; ProviderConfig providerConfig = new ProviderConfig(); providerConfig.setTimeout(timeout); providerConfig.setRetries(retries); providerConfig.setDelay(delay); providerConfig.setApplication(applicationConfig); providerConfig.setRegistry(registryConfig); providerConfig.setProtocol(protocolConfig); return providerConfig; &#125; // getter/setter&#125; 2.2、服务提供者实现接口提供者接口123456789101112131415package com.hhly.dubbo.service;import org.springframework.stereotype.Component;import com.alibaba.dubbo.config.annotation.Service;@Component@Service(version=\"1.0.0\")public class HelloProviderImpl implements HelloProvider &#123; @Override public String sayHello(String name) &#123; return \"hello dubbo-\" + name; &#125;&#125; 2.3、配置文件12345678910111213141516171819202122232425262728293031323334# 当前应用名称，用于注册中心计算应用间依赖关系，## 注意：消费者和提供者应用名不要一样，此参数不是匹配条件，## 你当前项目叫什么名字就填什么，# 和提供者消费者角色无关，比如：kylin应用调用了morgan应用的服务，则kylin项目配成kylin，# morgan项目配成morgan，可能kylin也提供其它服务给别人使用，但kylin项目永远配成kylin，# 这样注册中心将显示kylin依赖于morgan dubbo.application.name=application_provider# 日志输出方式，可选：slf4j,jcl,log4j,jdk dubbo.application.logger=slf4j# 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类dubbo.annotation.package=com.hhly.dubbo.service# 服务端口dubbo.protocol.name=dubbo# 协议端口dubbo.protocol.port=20880# 设为true，将向logger中输出访问日志，# 也可填写访问日志文件路径，直接把访问日志输出到指定文件 dubbo.protocol.accessLog=true# 服务方法调用超时时间(毫秒) dubbo.provider.timeout=3000# 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 dubbo.provider.retries=1# 延迟注册服务时间(毫秒)- ，设为-1时，表示延迟到Spring容器初始化完成时暴露服务dubbo.provider.delay=-1# 只调用指定协议的服务提供方，其它协议忽略。 dubbo.registr.protocol=zookeeper# 注册地址dubbo.registry.address=192.168.10.242:2181# 该协议的服务是否注册到注册中心 dubbo.registry.register=true# 是否向此注册中心订阅服务，如果设为false，将只注册，不订阅 dubbo.registry.subscribe=true 3、服务消费者代码3.1、服务消费者配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.hhly.dubbo.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import com.alibaba.dubbo.config.ApplicationConfig;import com.alibaba.dubbo.config.ConsumerConfig;import com.alibaba.dubbo.config.RegistryConfig;import com.alibaba.dubbo.config.spring.AnnotationBean;import com.alibaba.dubbo.rpc.Invoker;@Configuration@ConditionalOnClass(Invoker.class)@PropertySource(value = \"classpath:/dubbo.properties\")public class DubboConfiguration &#123; @Value(\"$&#123;dubbo.application.name&#125;\") private String applicationName; @Value(\"$&#123;dubbo.registr.protocol&#125;\") private String protocol; @Value(\"$&#123;dubbo.registry.address&#125;\") private String registryAddress; @Value(\"$&#123;dubbo.protocol.name&#125;\") private String protocolName; @Value(\"$&#123;dubbo.protocol.port&#125;\") private int protocolPort; @Value(\"$&#123;dubbo.provider.timeout&#125;\") private int timeout; /** * 设置dubbo扫描包 * @param packageName * @return */ @Bean public static AnnotationBean annotationBean(@Value(\"$&#123;dubbo.annotation.package&#125;\") String packageName) &#123; AnnotationBean annotationBean = new AnnotationBean(); annotationBean.setPackage(packageName); return annotationBean; &#125; /** * 注入dubbo上下文 * * @return */ @Bean public ApplicationConfig applicationConfig() &#123; // 当前应用配置 ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(this.applicationName); return applicationConfig; &#125; /** * 注入dubbo注册中心配置,基于zookeeper * * @return */ @Bean public RegistryConfig registryConfig() &#123; // 连接注册中心配置 RegistryConfig registry = new RegistryConfig(); registry.setProtocol(protocol); registry.setAddress(registryAddress); return registry; &#125; /** * 默认基于dubbo协议提供服务 * * @return *//* @Bean public ProtocolConfig protocolConfig() &#123; // 服务提供者协议配置 ProtocolConfig protocolConfig = new ProtocolConfig(); protocolConfig.setName(protocolName); protocolConfig.setPort(protocolPort); protocolConfig.setThreads(200); System.out.println(\"默认protocolConfig：\" + protocolConfig.hashCode()); return protocolConfig; &#125;*/ /** * dubbo消费 * * @param applicationConfig * @param registryConfig * @param protocolConfig * @return */ @Bean(name=\"defaultConsumer\") public ConsumerConfig providerConfig(ApplicationConfig applicationConfig, RegistryConfig registryConfig) &#123; ConsumerConfig providerConfig = new ConsumerConfig(); return providerConfig; &#125; // getter/setter&#125; 3.2、消费者服务调用类1234567891011121314151617181920package com.hhly.dubbo.service.impl;import org.springframework.stereotype.Component;import com.alibaba.dubbo.config.annotation.Reference;import com.hhly.dubbo.service.HelloProvider;import com.hhly.dubbo.service.HelloService;@Componentpublic class HelloServiceImpl implements HelloService&#123; @Reference(version = \"1.0.0\") private HelloProvider helloService; public String sayHello(String name) &#123; String sayHello = helloService.sayHello(name); return sayHello; &#125;&#125; 3.3、配置文件修改1dubbo.application.name=application_comsumer 需要注意一点，所定义的dubbo注解类是在dubbo配置dubbo.annotation.package的包下面，否则将无法识别，无法初始化。 4、pom.xml文件配置参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo-provider&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;dubbo-provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;com.hhly&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hhly&lt;/groupId&gt; &lt;artifactId&gt;dubbo-interface&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.10&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 5、遇到的问题5.1、dubbo-provider项目无法启动报错，报错信息如下：12345678Exception in thread \"main\" java.lang.NoSuchMethodError: org.springframework.core.annotation.AnnotationAwareOrderComparator.sort(Ljava/util/List;)V at org.springframework.boot.SpringApplication.getSpringFactoriesInstances(SpringApplication.java:404) at org.springframework.boot.SpringApplication.getSpringFactoriesInstances(SpringApplication.java:393) at org.springframework.boot.SpringApplication.initialize(SpringApplication.java:260) at org.springframework.boot.SpringApplication.&lt;init&gt;(SpringApplication.java:236) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1162) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1151) at com.hhly.dubbo.DubboProviderApplication.main(DubboProviderApplication.java:11) 问题分析：在没有引入dubbo-2.5.3.jar的情况下，项目是可以正常启动的，初步判断为jar包冲突，导致了该问题。于是去dubbo-2.5.3中找线索。 通过查看pom.xml文件发现dubbo-2.5.3有引入spring-2.5.6.SEC03 去spring-2.5.6.SEC03中找到AnnotationAwareOrderComparator类，发现该类中确实不存在sort()方法 解决办法：将引入的dubbo-2.5.3去除spring依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 5.2、dubbo-cosumer无法启动报错信息如下：12345678910111213141516171819202122java.lang.NullPointerException at com.alibaba.dubbo.config.spring.ReferenceBean.afterPropertiesSet(ReferenceBean.java:102) at com.alibaba.dubbo.config.spring.AnnotationBean.refer(AnnotationBean.java:292) at com.alibaba.dubbo.config.spring.AnnotationBean.postProcessBeforeInitialization(AnnotationBean.java:233) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:409) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1620) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542) at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:737) at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:370) at org.springframework.boot.SpringApplication.run(SpringApplication.java:314) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1162) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1151) at com.hhly.user.ComsumerApplication.main(ComsumerApplication.java:22) 断点到具体位置，发现该处有两个ApplicationConfig配置，并且其中一个为null 分析：如果此时的getConsumer().getApplication() 有值的话，就不会进入这个，于是想到在Configuration配置文件里面setter对应的值，修改Configuration文件的providerConfig()方法123456789@Bean(name=\"defaultConsumer\")public ConsumerConfig providerConfig(ApplicationConfig applicationConfig, RegistryConfig registryConfig) &#123; ConsumerConfig providerConfig = new ConsumerConfig(); // 手动注入，不再由spring容器去根据类名 // (com.alibaba.dubbo.config.ApplicationConfig)去获取对应的值 providerConfig.setApplication(applicationConfig); providerConfig.setRegistry(registryConfig); return providerConfig;&#125; 深层原因，为什么会获得两个配置，还不是很清楚，囧 6、参考dubbo用户指南","categories":[],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://yuechang.github.io/tags/Springboot/"},{"name":"dubbo","slug":"dubbo","permalink":"http://yuechang.github.io/tags/dubbo/"}]},{"title":"zookeeper 分布式集群安装","slug":"zookeeper分布式集群安装","date":"2017-05-21T06:39:08.000Z","updated":"2017-06-09T02:12:17.062Z","comments":true,"path":"2017/05/21/zookeeper分布式集群安装/","link":"","permalink":"http://yuechang.github.io/2017/05/21/zookeeper分布式集群安装/","excerpt":"","text":"zookeeper 集群安装 zookeeper 集群安装 本次搭建，将会搭建基本的zookeeper集群，三台，（要求3+，且必须是奇数，因为zookeeper的选举算法） 123456789101112架构图： +--------+ | leader | +--------+ | | +----+----+----+----+ | | | | +----------+ +----------+| follow 1 | | follow 2 |+----------+ +----------+ IP 端口 模式 领导端口 选举端口 192.168.10.242 2181 leader 28881 38881 192.168.10.242 2182 follow 28882 38882 192.168.10.242 2183 follow 28883 38883 1、环境 Linux：CentOS release 6.5 (Final) Kernel zookeeper：3.4.10 2、下载通过http://zookeeper.apache.org/releases.html#download下载zookeeper的稳定版本，本次是下载的3.4.10 3、解压与编译将zookeeper-3.4.10.tar.gz放入/data/app/zookeeper-cluster目录，并解压：12345678tar zxvf zookeeper-3.4.10.tar.gzmv zookeeper-3.4.10 zookeeper-3.4.10-1tar zxvf zookeeper-3.4.10.tar.gzmv zookeeper-3.4.10 zookeeper-3.4.10-2tar zxvf zookeeper-3.4.10.tar.gzmv zookeeper-3.4.10 zookeeper-3.4.10-3 4、建立/dataDir文件目录,并建立对应的myid文件进入/data/app/zookeeper-3.4.10目录，建立如下目录12345678mkdir -p /data/app/zookeeper-cluster/zookeeper-3.4.10-1/datamkdir -p /data/app/zookeeper-cluster/zookeeper-3.4.10-2/datamkdir -p /data/app/zookeeper-cluster/zookeeper-3.4.10-3/dataecho \"1\" &gt; /data/app/zookeeper-cluster/zookeeper-3.4.10-1/data/myidecho \"2\" &gt; /data/app/zookeeper-cluster/zookeeper-3.4.10-2/data/myidecho \"3\" &gt; /data/app/zookeeper-cluster/zookeeper-3.4.10-3/data/myid 5、配置文件进入/data/app/zookeeper-cluster/zookeeper-3.4.10-1/conf目录1cp zoo_sample.cfg zoo.cfg 编辑zoo1.cfg配置文件：12345678910111213141516171819202122232425262728293031323334353637# The number of milliseconds of each tick# 心跳时间(毫秒数)tickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgement# 这个配置项标识Leader与Follower之间发送消息，请求和应答时间长度，# 最长不能超过多少个 tickTime 的时间长度，总的时间长度就是5*2000=10秒syncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.# 数据存储目录dataDir=/data/app/zookeeper-cluster/zookeeper-3.4.10-1/data# the port at which the clients will connect# 客户端端口clientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to \"0\" to disable auto purge feature#autopurge.purgeInterval=1# (28881端口是leader的端口，38881端口是leader挂掉后选举leader用到的通讯渠道端口)server.1=192.168.10.242:28881:38881server.2=192.168.10.242:28882:38882server.3=192.168.10.242:28883:38883 复制zoo.cfg配置到对应目录，修改对应dataDir与clientPortzoo.conf12dataDir=/data/app/zookeeper-cluster/zookeeper-3.4.10-2/dataclientPort=2182 zoo.conf12dataDir=/data/app/zookeeper-cluster/zookeeper-3.4.10-3/dataclientPort=2183 注意：1.此次配置的server.x要与之前写入myid文件中的数字对应2.另外由于本次的三个zookeeper均在一台机器上，所以此次的server.1、server.2及server.3中的leader的端口与选举leader的端口是不一致的，如果部署在多台机器上，这三台配置的端口就不用这么折腾了，用同一份配置就好。 6、启动服务进入bin目录1./zkServer.sh start 7、验证服务是否启动进入bin目录1./zkServer.sh status 可以看到下面两种模式则说明已经成功启动","categories":[],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://yuechang.github.io/tags/zookeeper/"},{"name":"分布式","slug":"分布式","permalink":"http://yuechang.github.io/tags/分布式/"},{"name":"集群","slug":"集群","permalink":"http://yuechang.github.io/tags/集群/"}]},{"title":"redis-sentinel安装、配置与故障与故障转移演示","slug":"redis-sentinel安装、配置与故障与故障转移演示","date":"2017-05-12T10:39:08.000Z","updated":"2017-06-09T01:45:44.606Z","comments":true,"path":"2017/05/12/redis-sentinel安装、配置与故障与故障转移演示/","link":"","permalink":"http://yuechang.github.io/2017/05/12/redis-sentinel安装、配置与故障与故障转移演示/","excerpt":"","text":"redis-sentinel安装、配置与故障与故障转移演示redis-sentinel安装、配置与故障与故障转移演示本次搭建，将会搭建一个redis-sentinel，其中包括一主两从三哨兵。架构图如下：123456789101112131415161718192021 +-------------+ +-------------+ +-------------+| Sentinel S1 |------| Sentinel S2 |------| Sentinel S3 |+-------------+ +-------------+ +-------------+ | | | | | | +------+------+------+------+------+------+ | | +--------+ | Master | +--------+ | | +------++------+------++------+ | | | | +-----------+ +-----------+ | Salve S1 | | Salve S2 | +-----------+ +-----------+ 1、环境 Linux：CentOS release 6.5 (Final) Kernel redis：3.2.8 2、下载通过https://redis.io/下载redis的稳定版本，本次是下载的3.2.8 3、解压与编译将redis-3.2.8.tar.gz放入/data/app目录，并解压：1tar zxvf redis-3.2.8.tar.gz 进入/data/app/redis-3.2.8目录，编译：1make 4、建立日志/pid/dump文件目录进入/data/app/redis-3.2.8目录，建立如下目录123mkdir logsmkdir pidmkdir dump 5、修改配置文件复制配置123456789cp redis.conf redis.conf_bakcp redis.conf redis_6379.confcp redis.conf redis_6380.confcp redis.conf redis_6381.confcp sentinel.conf sentinel.conf_bakcp sentinel.conf sentinel_26379.confcp sentinel.conf sentinel_26379.confcp sentinel.conf sentinel_26379.conf 其中 备份配置 ：redis.conf_bak 备份配置 ：sentinel.conf_bak master配置：redis_6379.conf slave1配置：redis_6380.conf slave2配置：redis_6381.conf sentinel1 : sentinel_26379.conf sentinel2 : sentinel_26380.conf sentinel3 : sentinel_26381.conf 5.1、master配置(redis_6379.conf)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# Redis configuration file example.# 绑定IP地址bind 192.168.10.242# 设置为非保护模式protected-mode no# 设置端口port 6379# TCP listen() backlog.tcp-backlog 511# Unix socket.timeout 0# TCP keepalive.tcp-keepalive 300################################# GENERAL ###################################### 设置为以守护进程方式daemonize yessupervised no# 设置pid文件pidfile /data/app/redis-3.2.8/pid/redis_6379.pidloglevel notice# 设置日志目录logfile /data/app/redis-3.2.8/logs/redis_6379.logdatabases 16################################ SNAPSHOTTING ################################# 设置为不存储# save 900 1# save 300 10# save 60 10000stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yes# The filename where to dump the DB # 指定dump文件dbfilename dump_6379.rdb# The working directory. # 设置工作目录dir /data/app/redis-3.2.8/dump/################################# REPLICATION ################################## slaveof &lt;masterip&gt; &lt;masterport&gt;# masterauth &lt;master-password&gt;# 设置master密码masterauth adminslave-serve-stale-data yesslave-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-disable-tcp-nodelay noslave-priority 100################################## SECURITY #################################### requirepass foobared# 设置需要密码访问requirepass admin################################### LIMITS ##################################### maxclients 10000# maxmemory &lt;bytes&gt;############################## APPEND ONLY MODE ###############################appendonly noappendfilename \"appendonly.aof\"# appendfsync everysecappendfsync nono-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yes################################ LUA SCRIPTING ###############################lua-time-limit 5000################################ REDIS CLUSTER ###############################slowlog-log-slower-than 10000slowlog-max-len 128################################ LATENCY MONITOR ##############################latency-monitor-threshold 0############################# EVENT NOTIFICATION ##############################notify-keyspace-events \"\"############################### ADVANCED CONFIG ###############################hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-size -2list-compress-depth 0set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 10aof-rewrite-incremental-fsync yes 5.2、slave配置(redis_6380.conf/redis_6381.conf)将port,pidfile,logfile,dbfilename设置成与改端口对应的，另外需要加上如下配置：1slaveof 192.168.10.242 6379 5.3、sentinel配置sentinel_26379.conf配置如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Example sentinel.conf# *** IMPORTANT ***# port &lt;sentinel-port&gt;# The port that this sentinel instance will run on# 端口port 26379# sentinel announce-ip &lt;ip&gt;# sentinel announce-port &lt;port&gt;# 设置为非保护模式protected-mode no# sentinel announce-ip 1.2.3.4# dir &lt;working-directorydir /tmp# 设置为守护线程方式运行daemonize yes# 设置日志logfile /data/app/redis-3.2.8/logs/sentinel_26379.log# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;# 设置监听的master服务器(服务名，IP，端口，odown投票数)sentinel monitor mymaster 192.168.10.242 6379 2# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;# sentinel认证密码sentinel auth-pass mymaster admin# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;# Default is 30 seconds.# sentinel down-after-milliseconds mymaster 30000# 在一段时间内获取不到master的心跳时，将会认为该master为sdown状态，# 此处的设置值就是这个一段时间值，设置为3秒，默认为30秒sentinel down-after-milliseconds mymaster 3000# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;## How many slaves we can reconfigure to point to the new slave simultaneously# during the failover. Use a low number if you use the slaves to serve query# to avoid that all the slaves will be unreachable at about the same# time while performing the synchronization with the master.sentinel parallel-syncs mymaster 1# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;# Default is 3 minutes.# sentinel failover-timeout mymaster 180000# 故障转移时间，设置为5秒，默认为3分钟sentinel failover-timeout mymaster 5000# SCRIPTS EXECUTION## NOTIFICATION SCRIPT## sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;# # sentinel notification-script mymaster /var/redis/notify.sh## CLIENTS RECONFIGURATION SCRIPT## sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;## Example:# sentinel client-reconfig-script mymaster /var/redis/reconfig.sh 另外两个sentinel配置修改对应port，logfile配置即可。 6、启动redis-sentinel进入/data/app/redis-3.2.8/src目录，通过下面命令启动redis-sentinel，先主后从，最后哨兵1234567./redis-server ../redis_6379.conf./redis-server ../redis_6380.conf./redis-server ../redis_6381.conf./redis-sentinel ../sentinel_26379.conf./redis-sentinel ../sentinel_26380.conf./redis-sentinel ../sentinel_26381.conf 7、故障转移演示前提：将redis-sentinel成功启动； 如果master6379出现问题，sentinel1在设置的时间内无法获取到master6379的心跳，sentinel1投票master6379为sdown状态；将sentine投票数与quorum(配置文件中quorumw为2)比较，sentinel投票数小于quorum，未否达到了odown的条件，继续下一步； sentinel2，在设置的时间内无法获取到master6379的心跳，sentinel2投票master6379为sdown状态，sentinel投票数增加，将sentinel投票数与quorum比较，sentinel投票数等于quorum，达到odown条件； 开始进行故障转移 sentinel将会投票从salve6380和salve6381中选出新的master 选举出master，更新sentinel配置文件 故障转移完成注意：并不一定是sentinel1首先发现master6379有问题，本步骤只是说明这个过程； 进入/data/app/redis-3.2.8/src目录，将master6379 shutdown 1./redis-cli -h 192.168.10.242 -p 6379 -a admin shutdown 故障转移过程：1234567891011121314151617181920212227414:X 12 May 15:22:51.702 # Sentinel ID is bcd187b87f97488692628dff9ab94bdfddd1190727414:X 12 May 15:22:51.703 # +monitor master mymaster 192.168.10.242 6379 quorum 227414:X 12 May 15:22:51.704 * +slave slave 192.168.10.242:6380 192.168.10.242 6380 @ mymaster 192.168.10.242 637927414:X 12 May 15:22:51.726 * +slave slave 192.168.10.242:6381 192.168.10.242 6381 @ mymaster 192.168.10.242 637927414:X 12 May 15:22:58.002 * +sentinel sentinel 3251d086105f7131e1c39267fae42f27770bc40f 192.168.10.242 26380 @ mymaster 192.168.10.242 637927414:X 12 May 15:23:01.595 * +sentinel sentinel b003b642473ebfca5453666b4d587216971e0d23 192.168.10.242 26381 @ mymaster 192.168.10.242 6379// sentinel x 发现master6379状态异常，将master6379设置为sdown状态27414:X 12 May 15:25:44.992 # +sdown master mymaster 192.168.10.242 6379 // sentinel y 发现master6379状态异常，达到quorm条件，将master6379设置为odown状态27414:X 12 May 15:25:45.047 # +odown master mymaster 192.168.10.242 6379 #quorum 3/227414:X 12 May 15:25:45.047 # +new-epoch 1// 对master6379进行故障转移27414:X 12 May 15:25:45.047 # +try-failover master mymaster 192.168.10.242 6379// sentinel投票开始27414:X 12 May 15:25:45.100 # +vote-for-leader bcd187b87f97488692628dff9ab94bdfddd11907 127414:X 12 May 15:25:45.100 # 3251d086105f7131e1c39267fae42f27770bc40f voted for 3251d086105f7131e1c39267fae42f27770bc40f 127414:X 12 May 15:25:45.200 # b003b642473ebfca5453666b4d587216971e0d23 voted for 3251d086105f7131e1c39267fae42f27770bc40f 1// 3251d086105f7131e1c39267fae42f27770bc40f票数为2，成为新的master，更新sentinel配置文件27414:X 12 May 15:25:46.245 # +config-update-from sentinel 3251d086105f7131e1c39267fae42f27770bc40f 192.168.10.242 26380 @ mymaster 192.168.10.242 6379// 6381成为新的master，故障转移完成27414:X 12 May 15:25:46.245 # +switch-master mymaster 192.168.10.242 6379 192.168.10.242 638127414:X 12 May 15:25:46.246 * +slave slave 192.168.10.242:6380 192.168.10.242 6380 @ mymaster 192.168.10.242 6381 8、其他命令参考查看redis信息：1./redis-cli -h 192.168.10.242 -p 26379 -a admin info 查看sentinel信息：1./redis-cli -h 192.168.10.242 -p 26379 -a admin info 将对应redis服务停止1./redis-cli -h 192.168.10.242 -p 6379 -a admin shutdown 9、遇到的问题搭建完成后，无法连接上sentinel，telnet 192.168.10.242 26379错误信息如下：1234567891011-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients.In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to 'no', and then restarting the server.3) If you started the server manually just for testing, restart it with the '--protected-mode no' option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside. 解决方案：在sentinel配置文件中加上： # 设置为非保护模式 protected-mode no","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yuechang.github.io/tags/redis/"}]},{"title":"代理模式","slug":"代理模式","date":"2017-04-06T01:10:08.000Z","updated":"2017-06-09T01:41:42.078Z","comments":true,"path":"2017/04/06/代理模式/","link":"","permalink":"http://yuechang.github.io/2017/04/06/代理模式/","excerpt":"","text":"代理模式 1、代理模式1.1、应用场景当程序涉及修改数据库中数据操作时，此时的一般操作流程是： 1、开启事务 2、修改操作 3、提交事务或者回滚事务 随着时间的推移，代码中开启事务、提交事务及回滚事务的代码将变得冗余。记录日志在程序中也是推荐使用，那么记录日志也将变得冗余，同时设计具体业务操作的时候，往往还得考虑事务、日志等方面的操作，不能专注于业务操作。 为了解决代码冗余以及业务对象专注于业务操作，产生了代理模式。 1.2、组成部分代理模式有以下5部分组成： 1、target(目标对象/业务对象) 2、proxy(代理对象) 2、function(功能对象/事务对象、日志对象) 3、interceptor(拦截器对象) 4、client(客户端) 2、静态代理模式通过代理类去完成目标类的目标方面，并且在该目标的类特定的代理类中附加上额外的功能 静态代理模式代码实例： 目标类接口1234567891011/*** @ClassName: PersonDao* @Description: PersonDao接口* @author Yue Chang * @date 2017年3月23日 上午10:42:46 * @since 1.0*/public interface PersonDao &#123; public void deletePerson(); public void updatePerson();&#125; 目标类实现类12345678910111213141516171819/*** @ClassName: PersonDaoImpl* @Description: PersonDao接口实现类* @author Yue Chang * @date 2017年3月23日 上午10:42:05 * @since 1.0*/public class PersonDaoImpl implements PersonDao &#123; @Override public void deletePerson() &#123; System.out.println(\"delete Person !~\"); &#125; @Override public void updatePerson() &#123; System.out.println(\"update Person !~\"); &#125;&#125; 事务类123456789101112131415161718192021/*** @ClassName: Transaction* @Description: 事务类* @author Yue Chang * @date 2017年3月23日 上午10:45:19 * @since 1.0*/public class Transaction &#123; public void beginTransaction()&#123; System.out.println(\"begin transaction !~\"); &#125; public void commit()&#123; System.out.println(\"transaction commit !~\"); &#125; public void rollback()&#123; System.out.println(\"transaction rollback !~\"); &#125;&#125; 拦截器类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*** @ClassName: MyHandler* @Description: 拦截器类* @author Yue Chang * @date 2017年3月23日 上午11:54:30 * @since 1.0*/public class MyHandler implements PersonDao &#123; private Transaction transaction; private PersonDao personDaoTarget; /** * @param transaction * @param personDao */ public MyHandler(Transaction transaction, PersonDao personDao) &#123; super(); this.transaction = transaction; this.personDaoTarget = personDao; &#125; @Override public void deletePerson() &#123; try &#123; // 开启事务 transaction.beginTransaction(); // 目标类对象调用目标方法 personDaoTarget.deletePerson(); // 提交事务 transaction.commit(); &#125; catch (Exception e) &#123; // 回滚事务 transaction.rollback(); &#125; &#125; @Override public void updatePerson() &#123; try &#123; // 开启事务 transaction.beginTransaction(); // 目标类对象调用目标方法 personDaoTarget.updatePerson(); // 提交事务 transaction.commit(); &#125; catch (Exception e) &#123; // 回滚事务 transaction.rollback(); &#125; &#125; public Transaction getTransaction() &#123; return transaction; &#125; public void setTransaction(Transaction transaction) &#123; this.transaction = transaction; &#125; public PersonDao getPersonDaoTarget() &#123; return personDaoTarget; &#125; public void setPersonDaoTarget(PersonDao personDaoTarget) &#123; this.personDaoTarget = personDaoTarget; &#125;&#125; 客户端对象123456789101112131415161718192021/*** @ClassName: StaticProxyTest* @Description: 静态代理模式测试类* @author Yue Chang * @date 2017年3月23日 下午12:01:49 * @since 1.0*/public class StaticProxyTest &#123; @Test public void testStaticProxy()&#123; PersonDao personDao = new PersonDaoImpl(); Transaction transaction = new Transaction(); MyHandler myHandler = new MyHandler(transaction, personDao); myHandler.deletePerson(); System.out.println(); myHandler.updatePerson(); &#125;&#125; 程序执行结果：1234567begin transaction !~delete Person !~transaction commit !~begin transaction !~update Person !~transaction commit !~ 优点：。1、可以在不改变目标类的基础上，增加额外的功能，耦合度低；2、让目标类专注于业务开发，无需关注业务之外的功能；缺点：1、对于每一个目标类都需要编写一个handler，代码冗余，增加代码维护成本； 3、动态代理为了解决静态代理模式的代码冗余的缺点，以及继续保持低耦合的优点，也就有了动态代理模式。其中包括cglib动态代理模式和jdk动态代理模式。 3.1 jdk动态代理模式jdk动态代理模式代码实例： PersonDao接口1234567891011/*** @ClassName: PersonDao* @Description: PersonDao接口* @author Yue Chang * @date 2017年3月23日 上午10:42:46 * @since 1.0*/public interface PersonDao &#123; public void deletePerson(); public void updatePerson();&#125; PersonDao接口实现类12345678910111213141516171819/*** @ClassName: PersonDaoImpl* @Description: PersonDao接口实现类* @author Yue Chang * @date 2017年3月23日 上午10:42:05 * @since 1.0*/public class PersonDaoImpl implements PersonDao &#123; @Override public void deletePerson() &#123; System.out.println(\"delete Person !~\"); &#125; @Override public void updatePerson() &#123; System.out.println(\"update Person !~\"); &#125;&#125; 功能类(事务类）123456789101112131415161718192021/*** @ClassName: Transaction* @Description: 事务类* @author Yue Chang * @date 2017年3月23日 上午10:45:19 * @since 1.0*/public class Transaction &#123; public void beginTransaction()&#123; System.out.println(\"begin transaction !~\"); &#125; public void commit()&#123; System.out.println(\"transaction commit !~\"); &#125; public void rollback()&#123; System.out.println(\"transaction rollback !~\"); &#125;&#125; 拦截器1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @ClassName: MyHandler * @Description: 拦截器 * @author Yue Chang * @date 2017年3月23日 上午10:49:05 * @since 1.0 */public class MyHandler implements InvocationHandler &#123; private Object target; private Transaction transaction; /** * @param target 目标对象 * @param tansaction 事务对象 */ public MyHandler(Object target, Transaction transaction) &#123; super(); this.target = target; this.transaction = transaction; &#125; // invoke方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; // 开启事务 transaction.beginTransaction(); // 调用目标类的目标方法， method.invoke(target, args); // 提交事务 transaction.commit(); &#125; catch (Exception e) &#123; // 回滚事务 transaction.rollback(); &#125; return null; &#125; // getter/setter方法&#125; 客户端测试类123456789101112131415161718192021222324252627/*** @ClassName: JdkProxyTest* @Description: jdk动态代理客户端* @author Yue Chang * @date 2017年3月23日 上午10:56:36 * @since 1.0*/public class JdkProxyTest &#123; @Test public void testJdkProxy()&#123; // 目标对象 PersonDao target = new PersonDaoImpl(); // 事务对象 Transaction transaction = new Transaction(); // 拦截器对象 MyHandler myIntercepter = new MyHandler(target, transaction); // PersonDao代理对象 PersonDao proxy = (PersonDao) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), myIntercepter); proxy.deletePerson(); System.out.println(); proxy.updatePerson(); &#125;&#125; 代码执行结果：1234567begin transaction !~delete Person !~transaction commit !~begin transaction !~update Person !~transaction commit !~ 如果想再加入其他功能，比如日志，则需要在MyHandler类中，新增成员变量Logger，修改对应的构造方法，在invoke方法中增加对应操作。同时，如果觉得不需要事务，也同样可以操作MyHandler类来去除事务，这样的操作与目标类没有任何影响，完全松耦合。 3.2 cglib动态代理模式cglib动态代理模式与jdk动态代理模式类似，cglib动态代理模式代码如下：PersonDao接口123456789101112/*** @ClassName: PersonDao* @Description: PersonDao接口* @author Yue Chang * @date 2017年3月23日 上午10:42:46 * @since 1.0*/public interface PersonDao &#123; public void deletePerson(); public void updatePerson();&#125; PersonDao接口实现类12345678910111213141516171819/*** @ClassName: PersonDaoImpl* @Description: PersonDao接口实现类* @author Yue Chang * @date 2017年3月23日 上午10:42:05 * @since 1.0*/public class PersonDaoImpl implements PersonDao &#123; @Override public void deletePerson() &#123; System.out.println(\"delete Person !~\"); &#125; @Override public void updatePerson() &#123; System.out.println(\"update Person !~\"); &#125;&#125; 事务类123456789101112131415161718192021/*** @ClassName: Transaction* @Description: 事务类* @author Yue Chang * @date 2017年3月23日 上午10:45:19 * @since 1.0*/public class Transaction &#123; public void beginTransaction()&#123; System.out.println(\"begin transaction !~\"); &#125; public void commit()&#123; System.out.println(\"transaction commit !~\"); &#125; public void rollback()&#123; System.out.println(\"transaction rollback !~\"); &#125;&#125; cglib代理类拦截器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @ClassName: MyInterceptor * @Description: cglib代理类拦截器 * @author Yue Chang * @date 2017年3月23日 下午12:19:35 * @since 1.0 */public class MyInterceptor implements MethodInterceptor &#123; private Object target; private Transaction transaction; /** * @param target * @param transaction */ public MyInterceptor(Object target, Transaction transaction) &#123; super(); this.target = target; this.transaction = transaction; &#125; /** * @category 创建代理对象，可以在客户端完成 * @since cglib proxy * @author Yue Chang * @date 2017年3月31日 上午11:41:50 * @return */ public Object createProxy()&#123; Enhancer enhancer = new Enhancer(); enhancer.setCallback(this); enhancer.setSuperclass(target.getClass()); return enhancer.create(); &#125; @Override public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable &#123; try &#123; transaction.beginTransaction(); method.invoke(target, args); transaction.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); transaction.rollback(); &#125; return null; &#125; // getter/setter方法&#125; 客户端12345678910111213141516171819202122/*** @ClassName: CglibProxyTest* @Description: cglib代理模式测试类* @author Yue Chang * @date 2017年3月25日 下午3:48:01 * @since 1.0*/public class CglibProxyTest &#123; @Test public void testCglibProxy()&#123; PersonDao target = new PersonDaoImpl(); Transaction transaction = new Transaction(); MyInterceptor myInterceptor = new MyInterceptor(target, transaction); PersonDao proxy = (PersonDao) myInterceptor.createProxy(); proxy.deletePerson(); System.out.println(); proxy.updatePerson(); &#125;&#125; 程序运行结果：1234567begin transaction !~delete Person !~transaction commit !~begin transaction !~update Person !~transaction commit !~ 3.3 jdk动态代理模式和cglib动态代理模式的区别均在invoke方法中，对于复杂的逻辑处理比较困难。其中，具体方法由对应method参数决定。 jdk动态代理模式中，是通过Proxy.newProxyInstance来创建代理对象；cglib动态代理模式中，是通过Enhancer对象来创建代理对象； jdk动态代理模式中，代理类与目标类实现了相同的接口；cglib动态代理模式中，代理类是目标类的子类； 这一点区别其实也可以从创建代理对象中发现，jdk的获得目标类以及目标类的所有接口1Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), myIntercepter); cglib 将目标类设置为代理对象的超类1234Enhancer enhancer = new Enhancer(); enhancer.setCallback(this); enhancer.setSuperclass(target.getClass()); return enhancer.create(); 4、拓展可以申明一个Interceptor类，里面定义interceptor方法，将所有需要附加的功能类都实现Interceptor接口，将需要的操作在interceptor方法中实现，然后在动态代理模式中定义List interceptorList成员变量，初始化时传入interceptorList，在invoke方法中迭代此List，并执行Interceptor对象的interceptor方法，这样可以执行附加多个功能，并且不频繁改动拦截器类。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yuechang.github.io/tags/设计模式/"}]},{"title":"Maven安装依赖","slug":"Maven安装依赖","date":"2017-02-17T14:35:08.000Z","updated":"2017-06-09T01:44:47.204Z","comments":true,"path":"2017/02/17/Maven安装依赖/","link":"","permalink":"http://yuechang.github.io/2017/02/17/Maven安装依赖/","excerpt":"","text":"Maven安装依赖 环境信息：Linux：CentOS release 6.5 (Final)Nexus：2.14.2-01Windows:Windows 7Maven：3.2.3 1、本地安装依赖1.1、下载通过下载地址，下载合适的Maven文件 1.2、配置环境变量新建系统变量MAVEN_HOME变量值：D:\\apache-maven-3.2.3编辑系统变量Path添加变量值：;%MAVEN_HOME%\\bin在CMD中通过mvn –version命令，检查是否配置正确 1.3、安装依赖到本地通过如下命令来安装依赖1mvn install:install-file -DgroupId=com.zeroc -DartifactId=ice -Dversion=3.4.1 -Dpackaging=jar -Dfile=C:\\Users\\Administrator\\Desktop\\ice-3.4.1.jar 2、私服上安装依赖步骤1：步骤2：","categories":[],"tags":[{"name":"maven","slug":"maven","permalink":"http://yuechang.github.io/tags/maven/"}]},{"title":"搭建Maven私服","slug":"搭建Maven私服","date":"2017-02-15T03:35:08.000Z","updated":"2017-06-09T01:19:52.688Z","comments":true,"path":"2017/02/15/搭建Maven私服/","link":"","permalink":"http://yuechang.github.io/2017/02/15/搭建Maven私服/","excerpt":"","text":"本文地址：搭建Maven私服环境信息：Linux：CentOS release 6.5 (Final)Nexus：2.14.2-01 1、安装服务器1.1、下载下载如下文件(下载地址)： 1.2、解压解压下载的文件：1tar xzvf nexus-oss-webapp-1.8.0-bundle.tar.gz 1.3、启动进入/nexus-2.14.2-01/bin目录,看到Started Nexus OSS.就说明已经完成启动。 1.4、访问通过查看/nexus-2.14.2-01/logs/wrapper.log日志文件，查看对应的端口号 也可以查看配置文件查看配置的端口号，application-port对应的配置即为对应的端口号，此时配置是8888，默认为8081/nexus-2.14.2-01/conf/nexus.properties 我们可以在浏览器中通过下面URL进行访问，默认用户名和密码：admin/admin123http://192.168.33.107:8081/nexus/注意： 如果无法访问，可能是防火墙没有开放8081端口 其中默认用户名密码配置文件位置在：/sonatype-work/nexus/conf/security.xml文件中 2、配置Nexus2.1、修改配置通过admin用户登录后 2.2、更新索引 2.3、推荐设置2.1中的Remote Storage Location(远程仓库地址)设置是可选操作，不过，建议设置，可以加快jar下载速度。(阿里云中央仓库地址：http://maven.aliyun.com/nexus/content/groups/public/) 3、在项目中使用私服在pom.xml中增加repositories及pluginRepositories配置123456789101112131415161718192021&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;repositories&gt; &lt;repository&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://192.168.33.107:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://192.168.33.107:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt;","categories":[],"tags":[{"name":"maven","slug":"maven","permalink":"http://yuechang.github.io/tags/maven/"}]},{"title":"Unable to start EmbeddedWebApplicationContext due to missing EmbeddedServletContainerFactory bean","slug":"Spring-boot Unable to start EmbeddedWebApplicationContext due to missing EmbeddedServletContainerFactory bean","date":"2017-01-12T10:52:00.000Z","updated":"2017-01-20T10:29:15.477Z","comments":true,"path":"2017/01/12/Spring-boot Unable to start EmbeddedWebApplicationContext due to missing EmbeddedServletContainerFactory bean/","link":"","permalink":"http://yuechang.github.io/2017/01/12/Spring-boot Unable to start EmbeddedWebApplicationContext due to missing EmbeddedServletContainerFactory bean/","excerpt":"","text":"问题描述最初使用Spring boot进行建立了一个web项目，能够对http请求进行响应，支持REST风格访问。现在想去除web特性，从而不再有端口依赖。于是将对应依赖由spring-boot-starter-web修改成spring-boot-starter，修改完之后，项目无法启动报错信息如下：123456789101112131415org.springframework.context.ApplicationContextException: Unable to start embedded container; nested exception is org.springframework.context.ApplicationContextException: Unable to start EmbeddedWebApplicationContext due to missing EmbeddedServletContainerFactory bean. at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:133) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:766) at org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:361) at org.springframework.boot.SpringApplication.run(SpringApplication.java:307) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1191) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1180) at com.hhly.information.InformationApplication.main(InformationApplication.java:25)Caused by: org.springframework.context.ApplicationContextException: Unable to start EmbeddedWebApplicationContext due to missing EmbeddedServletContainerFactory bean. at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.getEmbeddedServletContainerFactory(EmbeddedWebApplicationContext.java:185) at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.createEmbeddedServletContainer(EmbeddedWebApplicationContext.java:158) at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:130) ... 8 common frames omitted 问题分析参考下面的说法结合自身的项目，推测应该是项目中还有web特性，导致项目无法启动。 解决办法于是去掉了对应的servlet、spring-web对应的依赖，可是，通过查看项目maven依赖列表，列表中还是存在spring-web的依赖，其他包引入了spring-web的依赖。通过IDEA Maven–&gt;Show Dependencies发现spring-hateoas包中有引入spring-web的包，于是去除对应依赖，问题解决。参考：https://github.com/spring-projects/spring-boot/issues/861","categories":[],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://yuechang.github.io/tags/Springboot/"}]},{"title":"syntax error near unexpected token `newline'脚本无法执行","slug":"syntax error near unexpected token `newline'脚本无法执行","date":"2016-12-30T09:29:00.000Z","updated":"2017-01-20T10:29:33.595Z","comments":true,"path":"2016/12/30/syntax error near unexpected token `newline'脚本无法执行/","link":"","permalink":"http://yuechang.github.io/2016/12/30/syntax error near unexpected token `newline'脚本无法执行/","excerpt":"","text":"问题描述执行run.sh脚本是报错，报错信息如下:12345/data/app/information-provider: No such file or directory: command not found./run.sh: line 4: syntax error near unexpected token `newline''/run.sh: line 4: `case \"$1\" in 问题分析查找脚本，脚本并没有问题， 于是怀疑是否文件格式不正确。通过下面命令查看文件，1cat -A run.sh 发现run.sh中，换行是以^M$结尾123456server=\"$( dirname \"$&#123;BASH_SOURCE[0]&#125;\" )\" &amp;&amp; pwd ^M$cd $server^M$^M$case \"$1\" in ^M$ ^M$ ... 解决办法执行下面语句将run.sh转换为linux环境下换行符$1dos2unix run.sh 通过cat -A run.sh查看转换文件为：12345server=\"$( dirname \"$&#123;BASH_SOURCE[0]&#125;\" )\" &amp;&amp; pwd $cd $server$$case \"$1\" in $ $","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yuechang.github.io/tags/服务器/"}]},{"title":"springboot-Mybatis多数据源配置","slug":"Spring-boot-Mybatis多数据源配置","date":"2016-12-05T15:50:50.000Z","updated":"2017-01-20T10:34:02.133Z","comments":true,"path":"2016/12/05/Spring-boot-Mybatis多数据源配置/","link":"","permalink":"http://yuechang.github.io/2016/12/05/Spring-boot-Mybatis多数据源配置/","excerpt":"","text":"环境信息：12Spring Boot:1.3.5Java:1.7 配置信息application.yml配置文件配置：12345678910111213141516171819202122232425262728293031323334# SPRING PROFILESspring: datasource: # 主数据源配置信息 primaryDataSource: url: jdbc:oracle:thin:@192.168.10.111:1521:orcl username: username password: password connectionTestQuery: SELECT 1+1 FROM DUAL dataSourceClassName: oracle.jdbc.pool.OracleDataSource typeAliasesPackage: com.hhly.template.entity.database mapperLocations: classpath:com/hhly/template/dao/database/*.xml configLocation: classpath:com/hhly/template/config/mybatis/mybatis-config.xml # 中间库数据源配置信息 middleDataSource: dataSourceClassName: oracle.jdbc.pool.OracleDataSource url: jdbc:oracle:thin:@192.168.2.222:1521:orcl username: username password: password max-idle: 10 max-wait: 10000 min-idle: 5 initial-size: 5 test-on-borrow: false test-while-idle: true time-between-eviction-runs-millis: 18800 cachePrepStmts: true prepStmtsSize: 250 prepStmtsCacheSqlLimit: 2048 userServerPrepStmts: true connectionTestQuery: SELECT 1+1 FROM DUAL typeAliasesPackage: com.hhly.template.entity.middatabase mapperLocations: classpath:com/hhly/template/dao/middatabase/*.xml configLocation: classpath:com/hhly/template/config/mybatis/mybatis-config.xml 数据源1配置信息：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @ClassName: MybatisConfiguration * @Description: 集成Mybatis * @author Yue Chang * @date 2016年9月7日 下午3:35:53 * @since 1.0 */@Configuration@ConditionalOnClass(&#123; EnableTransactionManagement.class, EntityManager.class &#125;)@MapperScan(basePackages = &#123; \"com.hhly.template.dao.database\" &#125;,sqlSessionFactoryRef=\"primarySqlSessionFactory\")public class PrimaryMybatisConfiguration implements EnvironmentAware &#123; private static Log logger = LogFactory.getLog(PrimaryMybatisConfiguration.class); private RelaxedPropertyResolver propertyResolver; private Environment env; public void setEnvironment(Environment environment) &#123; this.env = environment; this.propertyResolver = new RelaxedPropertyResolver(environment, \"spring.datasource.primaryDataSource.\"); &#125; @Bean(name = \"primaryDataSource\",destroyMethod=\"shutdown\") @Primary public DataSource dataSource() &#123; logger.info(\"Configruing primaryDataSource start...\"); HikariConfig config = new HikariConfig(); config.setDataSourceClassName(propertyResolver.getProperty(\"dataSourceClassName\")); config.addDataSourceProperty(\"url\", propertyResolver.getProperty(\"url\")); config.setUsername(propertyResolver.getProperty(\"username\")); config.setPassword(propertyResolver.getProperty(\"password\")); config.setConnectionTestQuery(propertyResolver.getProperty(\"connectionTestQuery\")) logger.info(\"Configruing primaryDataSource end...\"); return new HikariDataSource(config); &#125; @Bean(name = \"primarySqlSessionFactory\") @Primary public SqlSessionFactory sqlSessionFactory() &#123; try &#123; SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource()); sessionFactory.setTypeAliasesPackage(propertyResolver.getProperty(\"typeAliasesPackage\")); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(propertyResolver.getProperty(\"mapperLocations\"))); sessionFactory.setConfigLocation( new DefaultResourceLoader().getResource(propertyResolver.getProperty(\"configLocation\"))); logger.info(\"初始化sqlSessionFactory成功！\"); return sessionFactory.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(e.getMessage()); return null; &#125; &#125; @Bean(name = \"primaryTransactionManager\") @Primary public DataSourceTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125;&#125; 数据源2配置信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @ClassName: MiddleMybatisConfiguration * @Description: 中间库数据源配置 * @author Yue Chang * @date 2016年12月1日 下午3:33:26 * @since 1.0 */@Configuration@ConditionalOnClass(&#123; EnableTransactionManagement.class, EntityManager.class &#125;)@MapperScan(basePackages = &#123; \"com.hhly.template.dao.middatabase\" &#125;,sqlSessionFactoryRef=\"midSqlSessionFactory\")public class MiddleMybatisConfiguration implements EnvironmentAware &#123; private static Log logger = LogFactory.getLog(MiddleMybatisConfiguration.class); private RelaxedPropertyResolver propertyResolver; private Environment env; public void setEnvironment(Environment environment) &#123; this.env = environment; this.propertyResolver = new RelaxedPropertyResolver(environment, \"spring.datasource.middleDataSource.\"); &#125; @Bean(name = \"middleDataSource\",destroyMethod=\"shutdown\") public DataSource dataSource() &#123; logger.info(\"Configruing MiddleDataSource start...\"); HikariConfig config = new HikariConfig(); config.setDataSourceClassName(propertyResolver.getProperty(\"dataSourceClassName\")); config.addDataSourceProperty(\"url\", propertyResolver.getProperty(\"url\")); config.setUsername(propertyResolver.getProperty(\"username\")); config.setPassword(propertyResolver.getProperty(\"password\"));config.setConnectionTestQuery(propertyResolver.getProperty(\"connectionTestQuery\")); logger.info(\"Configruing MiddleDataSource end...\"); return new HikariDataSource(config); &#125; @Bean(name = \"midSqlSessionFactory\") public SqlSessionFactory sqlSessionFactory() &#123; try &#123; SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource()); sessionFactory.setTypeAliasesPackage(propertyResolver.getProperty(\"typeAliasesPackage\")); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(propertyResolver.getProperty(\"mapperLocations\"))); sessionFactory.setConfigLocation(new DefaultResourceLoader().getResource(propertyResolver.getProperty(\"configLocation\"))); logger.info(\"初始化sqlSessionFactory成功！\"); return sessionFactory.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(e.getMessage()); return null; &#125; &#125; @Bean(name = \"midTransactionManager\") public DataSourceTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125;&#125; 说明：1、MapperScan中的basePackages 需要不同的目录2、sqlSessionFactory和treansactionManager中如果使用下面方式可能会产生循环引用警告1234567@Bean(name = \"primaryTransactionManager\")@Primarypublic DataSourceTransactionManager transactionManager(@Qualifier(\"primaryDataSource\") DataSource primaryDataSource) &#123;...&#125;@Bean(name = \"primarySqlSessionFactory\")@Primarypublic SqlSessionFactory sqlSessionFactory(@Qualifier(\"primaryDataSource\") DataSource primaryDataSource) &#123;...&#125; 警告信息如下：12016-12-05 10:05:36 [main] WARN org.springframework.beans.factory.support.DefaultListableBeanFactory -Bean creation exception on non-lazy FactoryBean type check: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dictionaryMapper' defined in file [D:\\neon-workspace\\template\\target\\classes\\com\\hhly\\template\\dao\\database\\DictionaryMapper.class]: Cannot resolve reference to bean 'primarySqlSessionFactory' while setting bean property 'sqlSessionFactory'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'primarySqlSessionFactory': Requested bean is currently in creation: Is there an unresolvable circular reference? 解决办法：1、将dataSouce 在其他类中定义，再注入；2、去掉参数，需要dataSource的时候，通过dataSource()方法获得，只会初始化一次。","categories":[],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://yuechang.github.io/tags/Springboot/"}]},{"title":"java.io.File中mkdir和mkdirs的差别","slug":"java-io-File中mkdir和mkdirs的差别","date":"2016-11-17T06:29:51.000Z","updated":"2017-01-20T10:05:04.664Z","comments":true,"path":"2016/11/17/java-io-File中mkdir和mkdirs的差别/","link":"","permalink":"http://yuechang.github.io/2016/11/17/java-io-File中mkdir和mkdirs的差别/","excerpt":"","text":"mkdirs()可以成功建立多级文件夹， mkdir()只能成功建立一级的文件夹，多层目录就不能创建成功 123456789101112131415161718192021222324252627private String path = \"D:/folder/subFolder\";private String fileName = \"temp.txt\";@Testpublic void testMkdir() throws Exception &#123; String tempPath = path.concat(File.separator).concat(fileName); File file = new File(tempPath); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdir(); &#125; file.createNewFile();&#125;@Testpublic void testMkdirs() throws Exception &#123; String tempPath = path.concat(File.separator).concat(fileName); File file = new File(tempPath); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; file.createNewFile(); &#125; 程序运行将抛出：java.io.IOException: 系统找不到指定的路径。因为mkdir()方法没有成功创建多层目录。 建议使用：mkdirs()方法","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yuechang.github.io/tags/java/"}]},{"title":"本地Eclipse中Tomcat运行测试环境代码","slug":"本地Eclipse中Tomcat运行测试环境代码","date":"2016-10-15T15:00:37.000Z","updated":"2017-01-20T04:25:26.812Z","comments":true,"path":"2016/10/15/本地Eclipse中Tomcat运行测试环境代码/","link":"","permalink":"http://yuechang.github.io/2016/10/15/本地Eclipse中Tomcat运行测试环境代码/","excerpt":"","text":"1、复制测试环境代码对应项目到本地2、对本地Eclipse中server.xml2.1、找到Eclipse下面的Servers下的server.xml文件： 2.2、将xml中Host元素下代码配置进行修改：12345678&lt;Host appBase=\"webapps\" autoDeploy=\"true\" name=\"localhost\" unpackWARs=\"true\"&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" prefix=\"localhost_access_log.\" suffix=\".txt\"/&gt; &lt;!-- 将已部署的项目删除，或者将下面这段部署项目的配置注释 --&gt; &lt;!-- &lt;Context docBase=\"temp\" path=\"/temp\" reloadable=\"true\" source=\"org.eclipse.jst.jee.server:mlottery\"/&gt; --&gt; &lt;!-- 增加如下配置，其中修改对应的docBase对应的路径及path--&gt; &lt;Context crossContext=\"true\" debug=\"0\" docBase=\"C:\\Users\\Administrator\\Desktop\\temp\" path=\"/temp\" reloadable=\"false\"/&gt; &lt;/Host&gt; 3、点击启动Tomcat按钮即可将测试环境代码运行起来如果想修改代码，其对应java文件将会自动编译在\\WebRoot\\WEB-INF\\classes目录下，如果要排查是哪个位置代码不一致导致的，需要将对应class文件替换即可进行排查","categories":[],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://yuechang.github.io/tags/Eclipse/"}]},{"title":"Spring-boot打成jar包问题总结","slug":"Spring-boot打成jar包问题总结","date":"2016-09-09T10:54:19.000Z","updated":"2017-01-20T10:29:44.777Z","comments":true,"path":"2016/09/09/Spring-boot打成jar包问题总结/","link":"","permalink":"http://yuechang.github.io/2016/09/09/Spring-boot打成jar包问题总结/","excerpt":"","text":"Spring boot 打成jar包问题总结1、Unable to find a single main class from the following candidates1.1、问题描述maven build时出现以下错误提示日志：1[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:1.3.5.RELEASE:repackage (default) on project information: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:1.3.5.RELEASE:repackage failed: Unable to find a single main class from the following candidates [com.hhly.InformationApplication, com.hhly.test.Application] -&gt; [Help 1] 1.2、日志分析12Unable to find a single main class from the following candidates [com.hhly.InformationApplication, com.hhly.test.Application]// 不能从下面的候选类中找到单一的main类 1.3、解决办法查看着两个类，发现两个类中确实两个类中均有一个main方法，去掉一个多余的main方法，保留唯一的main方法。 2、jar中没有主清单属性2.1、问题描述生产对应的jar包之后，通过一下命令运行spring boot程序，1java -jar information-0.0.1-SNAPSHOT.jar 2.2、问题分析查找资料发现为最后生成的jar包中的META-INF/MANIFEST.MF文件，没有设置主函数信息。猜想是pom.xml设置的问题，比对网上的设置，发现多数配置都是如下：123456789101112131415161718192021222324252627&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;maimClass&gt;com.hhly.InformationApplication&lt;/maimClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 比对自己的设置发现：自己在标签外面还包了一个 pluginManagement标签。 2.3、解决办法去掉pluginManagement标签。 3、Property ‘sqlSessionFactory’ or ‘sqlSessionTemplate’ are required3.1、问题描述首先通过maven clean，然后再执行maven build，在执行main函数时会出现下面错误，详细日志如下：12342016-09-09 18:29:43.419 WARN 37076 --- [ost-startStop-1] o.s.b.f.s.DefaultListableBeanFactory : Bean creation exception on non-lazy FactoryBean type check: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userMapper' defined in file [D:\\neon-workspace\\information\\target\\classes\\com\\hhly\\dao\\UserMapper.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required 3.2、问题分析同样的代码，在通过Alt + F5更新项目，然后maven build生成jar包，最后执行的main的时候也就不会报错。 3.3、解决办法调整打包顺序如下：1、Alt + F52、maven build","categories":[],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://yuechang.github.io/tags/Springboot/"}]},{"title":"Unhandled event loop exception No more handles","slug":"Unhandled event loop exception No more handles","date":"2016-08-02T01:57:20.000Z","updated":"2017-01-20T11:43:27.980Z","comments":true,"path":"2016/08/02/Unhandled event loop exception No more handles/","link":"","permalink":"http://yuechang.github.io/2016/08/02/Unhandled event loop exception No more handles/","excerpt":"","text":"1、问题描述软件环境：Eclipse 4.5系统环境：Win 7使用Eclipse中Synchronizing视图时，每次点更改的文件时出现以下错误： 查看错误详情： 2、解决办法各种百度之后得出的结论是与其他软件的键冲突了，但是没有哪篇明确说明是哪个软件产生的冲突，最后在stack overflow上面找到了答案，是teamviewer产生的冲突。 进入TeamViewer选项，找到计算机与联系人高级设置； 然后点击QuickConnection右边的配置； 去掉显示QuickConnection按钮的勾，问题解决。 3、参考http://stackoverflow.com/questions/15594590/eclipse-bug-unhandled-event-loop-exception-no-more-handles","categories":[],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://yuechang.github.io/tags/Eclipse/"}]},{"title":"MongoDB3.2配置文件directoryPerDB参数","slug":"MongoDB3-2配置文件directoryPerDB参数","date":"2016-07-25T13:52:32.000Z","updated":"2016-07-25T13:53:14.568Z","comments":true,"path":"2016/07/25/MongoDB3-2配置文件directoryPerDB参数/","link":"","permalink":"http://yuechang.github.io/2016/07/25/MongoDB3-2配置文件directoryPerDB参数/","excerpt":"","text":"MongoDB3.2 使用过一段时间之后，想要配置下directoryPerDB参数，于是在mongod.conf配置文件storage下加入：1directoryPerDB: true 服务重启时报错信息如下：1234567891011121314152016-07-21T02:47:14.007-0700 I CONTROL [main] ***** SERVER RESTARTED *****2016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] MongoDB starting : pid=2740 port=27017 dbpath=/home/martin/mongodb/db 64-bit host=localhost.localdomain2016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] db version v3.2.82016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] git version: ed70e33130c977bda0024c125b56d159573dbaf02016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 20132016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] allocator: tcmalloc2016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] modules: enterprise 2016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] build environment:2016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] distmod: rhel622016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] distarch: x86_642016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] target_arch: x86_642016-07-21T02:47:14.020-0700 I CONTROL [initandlisten] options: &#123; config: \"/home/martin/mongodb/bin/mongod.conf\", net: &#123; bindIp: \"0.0.0.0\", port: 27017 &#125;, processManagement: &#123; fork: true, pidFilePath: \"/home/martin/mongodb/mongod.pid\" &#125;, security: &#123; authorization: \"enabled\" &#125;, storage: &#123; dbPath: \"/home/martin/mongodb/db\", directoryPerDB: true, journal: &#123; enabled: true &#125; &#125;, systemLog: &#123; destination: \"file\", logAppend: true, path: \"/home/martin/mongodb/logs/mongod.log\" &#125; &#125;2016-07-21T02:47:14.041-0700 I - [initandlisten] Detected data files in /home/martin/mongodb/db created by the 'wiredTiger' storage engine, so setting the active storage engine to 'wiredTiger'.2016-07-21T02:47:14.042-0700 I STORAGE [initandlisten] exception in initAndListen: 72 Requested option conflicts with current storage engine option for directoryPerDB; you requested true but the current server storage is already set to false and cannot be changed, terminating2016-07-21T02:47:14.042-0700 I CONTROL [initandlisten] dbexit: rc: 100 根据错误日志提示：1[initandlisten] exception in initAndListen: 72 Requested option conflicts with current storage engine option for directoryPerDB; you requested true but the current server storage is already set to false and cannot be changed, terminating 初始化失败，当前directoryPerDB选项存储引擎有72个选项冲突，你要求true，但是当前存储服务已经设置为false，并且无法改变，程序终止。 解决办法：1、删除dbPath文件夹下所有文件，重启MongoDB服务；2、导出MongoDB 存储文件，删除dbPath文件夹下所有文件，重启MongoDB服务，导入导出的数据；","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yuechang.github.io/tags/MongoDB/"}]},{"title":"MongoDB 3.2.7安装及用户角色配置","slug":"MongoDB-3-2-7安装及用户角色配置","date":"2016-07-20T12:04:49.000Z","updated":"2016-07-20T12:05:45.978Z","comments":true,"path":"2016/07/20/MongoDB-3-2-7安装及用户角色配置/","link":"","permalink":"http://yuechang.github.io/2016/07/20/MongoDB-3-2-7安装及用户角色配置/","excerpt":"","text":"1、MongDB安装步骤1.1、下载安装包环境信息：Linux：CentOS release 6.5 (Final)MongoDB：3.2.7MongoDB下载地址：http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-rhel62-3.2.7.tgz 1.2、解压1tar -zxvf mongodb-linux-x86_64-enterprise-rhel62-3.2.7.tgz 1.3、指定安装目录1mv mongodb-linux-x86_64-enterprise-rhel62-3.2.7 /home/martin/ 并重命名为mongodb 1.4、新建目录新建MongoDB数据文件存放目录1mkdir -p /home/martin/mongodb/db 新建log文件存放目录1mkdir -p /home/martin/mongodb/logs 1.5、新建配置文件MongoDB支持把参数写进配置文件，mongod.conf配置文件内容如下123456789101112131415161718192021222324252627282930313233343536373839404142# mongod.conf# for documentation of all options, see:# http://docs.mongodb.org/manual/reference/configuration-options/# where to write logging data.systemLog: destination: file logAppend: true path: /home/martin/mongodb/logs/mongod.log #日志文件存放目录# Where and how to store data.storage: dbPath: /home/martin/mongodb/db #数据文件存放目录 journal: enabled: true# engine:# mmapv1:# wiredTiger:# how the process runsprocessManagement: fork: true #以守护程序的方式启用，即在后台运行 pidFilePath: /home/martin/mongodb/mongod.pid # location of pidfile# network interfacesnet: port: 27017 #端口 bindIp: 0.0.0.0 # Listen to local interface only, comment to listen on all interfaces.#security: #authorization: enabled #operationProfiling:#replication:#sharding:## Enterprise-Only Options#auditLog:#snmp: 1.6、启动MongoDB服务器使用配置文件mongod.conf定义的参数启动1/home/martin/mongodb/bin/mongod --config /home/martin/mongodb/bin/mongod.conf 1.7、配置开机启动vi /etc/rc.d/rc.local在文件末端加入：1/home/martin/mongodb/bin/mongod --config /home/martin/mongodb/bin/mongod.conf 1.8、安装防火墙服务并开启端口安装防火墙服务1yum install iptables services 防火墙开启27017端口打开配置文件1vi /etc/sysconfig/iptables 加入如下语句1-A INPUT -p tcp -m state --state NEW -m tcp --dport 27107 -j ACCEPT 重启防火墙1service iptables start 1.9、测试连接1、通过xshell连接对应linux服务器，到MongoDB安装的bin目录运行./mongo命令2、telnet ip 27017 2、 MongoDB用户角色配置2.1、基本知识介绍MongoDB基本的角色1.数据库用户角色：read、readWrite;2.数据库管理角色：dbAdmin、dbOwner、userAdmin；3.集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；4.备份恢复角色：backup、restore；5.所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase6.超级用户角色：root//这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase） 其中MongoDB默认是没有开启用户认证的，也就是说游客也拥有超级管理员的权限。userAdminAnyDatabase：有分配角色和用户的权限，但没有查写的权限 2.2、操作步骤2.2.1、连接到MongoDB服务器1./mongo 2.2.2、创建root/admin用户12345678910use admindb.createUser(&#123;user:\"root\",pwd:\"password\",roles:[\"root\"]&#125;)db.createUser( &#123; user: \"admin\", pwd: \"password\", roles: [&#123;role: \"userAdminAnyDatabase\", db: \"admin\"&#125;] &#125; ) 2.2.3、修改mongod.conf文件在配置文件中增加如下配置12security: authorization: enabled //启用授权 2.2.4、重启MongoDB服务器1service mongod restart 2.2.5、创建数据库读写权限用户12345678use admindb.auth(\"admin\",\" password\");use ballmatchdb.createUser(&#123; user: \"football\", pwd: \"password\", roles: [&#123;role: \"readWrite\",db: \"ballmatch\"&#125;]&#125;) 2.2.6、Java程序连接MongoDB服务器123456789101112//方式一MongoCredential credential = MongoCredential.createCredential(\"username\", \"dbName\", \"password\".toCharArray());ServerAddress serverAddress = new ServerAddress(\"192.168.10.242\", 27017);MongoClient mongoClient = new MongoClient(serverAddress, Arrays.asList(credential));DB db = mongoClient.getDB(\"dbName\");return db;//方式二String sURI = String.format(\"mongodb://%s:%s@%s:%d/%s\", \"username\", \"password\", \"192.168.10.242\", 27017, \"dbName\"); MongoClientURI uri = new MongoClientURI(sURI); MongoClient mongoClient = new MongoClient(uri); DB db = mongoClient.getDB(\"dbName\"); 3、命令参考3.1、修改用户密码1db.updateUser( \"admin\",&#123;pwd:\"password\"&#125;); 3.2、密码认证1db.auth(\"admin\",\"password\"); 3.3、MongoDB连接信息查询1db.serverStatus().connections; MongoDB实例接受的最多连接数，如果高于操作系统接受的最大线程数，设置无效。net.maxIncomingConnections默认（65536） 3.4、关闭MongoDB服务12use admin;db.shutdownServer(); 3.5、删除用户删除用户(需要root权限，会将所有数据库中的football用户删除)1db.system.users.remove(&#123;user:\"football\"&#125;); 删除用户(权限要求没有那么高，只删除本数据中的football用户)1db.dropUser(\"football\");","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yuechang.github.io/tags/MongoDB/"}]},{"title":"Java webSocket 网页聊天室","slug":"Java webSocket 网页聊天室","date":"2016-07-14T06:40:11.000Z","updated":"2016-07-16T04:47:16.616Z","comments":true,"path":"2016/07/14/Java webSocket 网页聊天室/","link":"","permalink":"http://yuechang.github.io/2016/07/14/Java webSocket 网页聊天室/","excerpt":"","text":"webSocket简介webSocket是ajax轮询与long pull方式的改进。ajax轮询：每隔一段时间请求一次，不管有没有新信息；long pull：每次请求之后，等到有新信息才会返回；webSocket：客户端发送一次请求之后，只要有新信息，服务器就会主动把数据推送过去。 效果截图参考了网上的例子来实现聊天室，实验楼的那个不错！但是，打开两个页面却不能真正的聊天，后面参考Tomcat下的ChatAnnotation.java综合两者，才有了这个聊天室。 效果图1： 效果图2： 增加代码后台代码增加以下几点： 1、在会话打开时，将对应的session添加到对应map中； 2、当发送消息时，遍历整个map，然后对每个session发送消息； 3、关闭时，将对应的session从map中删除，不再接收消息,并且如果此用户有发送过消息，系统将提示该用户已下线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 聊天服务器类 * * @author yuechang * */@ServerEndpoint(\"/websocket\")public class ChatServer &#123; private Session session; private static final Map&lt;ChatServer, String&gt; connections = new ConcurrentHashMap&lt;ChatServer, String&gt;(); // 日期格式化 private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm\"); /** * @category 添加初始化操作 * @param session */ @OnOpen public void open(Session session) &#123; // 开启会话，将session存入map中，不过此时的nikename存入的为空字符串 this.session = session; connections.put(this, \"\"); &#125; /** * @category 接受客户端的消息，并把消息发送给所有连接的会话 * @param message * 客户端发来的消息 * @param session * 客户端的会话 */ @OnMessage public void getMessage(String message, Session session) &#123; // 把客户端的消息解析为JSON对象 JSONObject jsonObject = JSONObject.fromObject(message); // 获得昵称 String nikename = (String) jsonObject.get(\"nickname\"); connections.put(this, nikename); broadcast(message); &#125; /** * @category 添加关闭会话时的操作 * @param reason */ @OnClose public void close(CloseReason reason) &#123; String nikename = connections.get(this); // 下线时，得从总人数中移除，否则信息公布时找不到下线的session报错的 connections.remove(this); // 如果这个人有在聊天室中发过言，则向聊天室中发送nikename已下线消息 if (StringUtils.isNotBlank(nikename)) &#123; String msg = \"&#123;'content':'&lt;p&gt;用户[ \".concat(nikename) .concat(\" ]下线了！&lt;br/&gt;&lt;/p&gt;','nickname':'系统消息'&#125;\"); broadcast(msg);// 这是告知所还在线聊天的人下线了 &#125; &#125; /** * @category 添加处理错误的操作 * @param t */ @OnError public void error(Throwable t) &#123; // 添加处理错误的操作 &#125; /** * @category 广播消息 * @param msg * 消息JSON串 */ private void broadcast(String msg) &#123; Iterator&lt;ChatServer&gt; iterator = connections.keySet().iterator(); while (iterator.hasNext()) &#123; ChatServer client = iterator.next(); synchronized (client) &#123; // 把客户端的消息解析为JSON对象 JSONObject jsonObject = JSONObject.fromObject(msg); // 在消息中添加发送日期 jsonObject.put(\"date\", DATE_FORMAT.format(new Date())); // 添加本条消息是否为当前会话本身发的标志 jsonObject.put(\"isSelf\", client.session.equals(session)); // 发送JSON格式的消息 client.session.getAsyncRemote().sendText(jsonObject.toString()); &#125; &#125; &#125;&#125; 遇到的问题在Maven项目中，由于web.xml申明的web-app是2.3版本的，不支持JSP内置对象，需要进行web.xml申明为：123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt;&lt;/web-app&gt; 然后再JSP页面加上：1&lt;%@ page isELIgnored=\"false\" %&gt; 项目下载地址https://github.com/yuechang/webSocket.git 博文参考： http://zhihu.com/question/20215561/answer/40316953 http://shiyanlou.iteye.com/blog/2182565 apache-tomcat-7.0.63\\webapps\\examples\\WEB-INF\\classes\\websocket\\chat\\ChatAnnotation.java","categories":[],"tags":[]},{"title":"The value of the project attribute is null","slug":"The value of the project attribute is null","date":"2016-07-11T10:40:11.000Z","updated":"2016-07-16T04:49:58.017Z","comments":true,"path":"2016/07/11/The value of the project attribute is null/","link":"","permalink":"http://yuechang.github.io/2016/07/11/The value of the project attribute is null/","excerpt":"","text":"问题描述导入Maven项目后，无法进行Update Maven project操作，报错信息如下：1The value of the project attribute is null Maven Java EE Configuration Problem 解决办法可以尝试以下解决办法： 首先，找到对应项目所在的文件目录，将.settings以及.project文件删除； 然后，删除Eclipse中的对应项目(注意：不要把删除本地文件的勾勾上)； 最后，重新导入项目，并对项目进行更新操作。","categories":[],"tags":[]},{"title":"SpringMVC事务管理器不起作用","slug":"SpringMVC事务管理器不起作用","date":"2016-07-06T10:23:11.000Z","updated":"2016-07-16T02:38:49.847Z","comments":true,"path":"2016/07/06/SpringMVC事务管理器不起作用/","link":"","permalink":"http://yuechang.github.io/2016/07/06/SpringMVC事务管理器不起作用/","excerpt":"","text":"问题描述通过Spring MVC + MySQL配置事务，事务配置没有问题，删除数据之后，抛出异常，但是事务没有回滚。 解决办法最后发现原来是MySQL表的引擎为：MyISAM，导致不支持事务。修改对应建表语句，指定引擎为 1ENGINE=InnoDB DEFAULT CHARSET=utf8; 原因验证可以通过下面方式来验证，是否是这个原因导致事务不会滚。在Navicat Premium工具中，右击对应的表，进入Object Information，进入DDL标签：如果发现对应的ENGINE为MyISAM，则表示这种引擎不支持事务。","categories":[],"tags":[]},{"title":"Invalid content was found starting with element 'init-param'","slug":"cvc-complex-type.2.4.a Invalid content was found starting with element init-param","date":"2016-06-28T02:39:58.000Z","updated":"2016-07-16T04:53:26.000Z","comments":true,"path":"2016/06/28/cvc-complex-type.2.4.a Invalid content was found starting with element init-param/","link":"","permalink":"http://yuechang.github.io/2016/06/28/cvc-complex-type.2.4.a Invalid content was found starting with element init-param/","excerpt":"","text":"web.xml文件中:12345678910&lt;servlet&gt; &lt;servlet-name&gt;Zblog&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 第六行报错，报错信息如下：123cvc-complex-type.2.4.a: Invalid content was found starting with element 'init-param'. One of '&#123;\"http:// java.sun.com/xml/ns/javaee\":run-as, \"http://java.sun.com/xml/ns/javaee\":security-role-ref, \"http://java.sun.com/xml/ns/javaee\":multipart-config&#125;' is expected. 解决办法：将4、5行移到9行和10行之间，最终效果如下：12345678910&lt;servlet&gt; &lt;servlet-name&gt;Zblog&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt;","categories":[],"tags":[]},{"title":"如何正确的实现Java中的hashCode方法","slug":"如何正确的实现Java中的hashCode方法","date":"2016-06-22T02:50:58.000Z","updated":"2016-07-16T02:40:31.601Z","comments":true,"path":"2016/06/22/如何正确的实现Java中的hashCode方法/","link":"","permalink":"http://yuechang.github.io/2016/06/22/如何正确的实现Java中的hashCode方法/","excerpt":"","text":"你知道一个对象的唯一标志不能仅仅通过写一个漂亮的equals来实现太棒了，不过现在你也必须实现hashCode方法。 让我们看看为什么和怎么做才是正确的。 相等和哈希码相等是从一般的方面来讲，哈希码更加具有技术性。如果我们在理解方面存在困难,我们可以说,他们通过只是一个实现细节来提高了性能。 大多数的数据结构通过equals方法来判断他们是否包含一个元素，例如：12List&lt;String&gt; list = Arrays.asList(\"a\", \"b\", \"c\");boolean contains = list.contains(\"b\"); 这个变量contains结果是true，因为,虽然”b”是不相同的实例(此外,忽略字符串驻留),但是他们是平等的。 通过比较实例的每个元素，然后将比较结果赋值给contains是比较浪费的，虽然整个类的数据结构进行了优化，能够提升性能。他们通过使用一种快捷的方式(减少潜在的实例相等)进行比较，从而代替通过比较实例所包含的每个元素。而快捷比较仅需要比较下面这些方面： 快捷方式比较即通过比较哈希值，它可以将一个实例用一个整数值来代替。哈希码相同的实例不一定相等，但相等的实例一定具有有相同的哈希值。(或应该有,我们很快就会讨论这个)这些数据结构经常通过这种这种技术来命名,可以通过Hash来识别他们的,其中，HashMap是其中最著名的代表。 它们通常是这样这样运作的 当添加一个元素,它的哈希码是用来计算内部数组的索引(即所谓的桶) 如果是,不相等的元素有相同的哈希码,他们最终在同一个桶上并且捆绑在一起,例如通过添加到列表。 当一个实例来进行contains操作时，它的哈希码将用来计算桶值(索引值)，只有当对应索引值上存在元素时，才会对实例进行比较。 因此equals，hashCode是定义在Object类中。 散列法的思想如果hashCode作为快捷方式来确定相等，那么只有一件事我们应该关心:相等的对象应该具有相同的哈希码这也是为什么如果我们重写了equals方法后，我们必须创建一个与之匹配的hashCode实现!否则相等的对象是可能不会有相同的哈希码,因为它们将调用的是Object&#39;s的默认实现。 HashCode 准则引用自官方文档 hashCode通用约定: 调用运行Java应用程序中同一对象,hashCode方法必须始终返回相同的整数。这个整数不需要在不同的Java应用程序中保持一致。 根据equals(Object)的方法来比较，如果两个对象是相等的,两个对象调用hashCode方法必须产生相同的结果。 根据equals(Object)的方法是比较，如果两个对象是不相等的，那么两个对象调用hashCode方法并不一定产生不同的整数的结果。但是,程序员应该意识到给不平等的对象产生不同的整数结果将有可能提高哈希表的性能。 第一点反映出了相等的一致性属性，第二个就是我们上面提出的要求。第三个阐述了一个重要的细节，我们将在稍后讨论。 HashCode实现下面是非常简单的Person.hashCode的实现1234@Overridepublic int hashCode() &#123; return Objects.hash(firstName, lastName);&#125; person’s是通过多个字段结合来计算哈希码的。都是通过Object的hash函数来计算。 选择字段但哪些字段是相关的吗?需求将会帮助我们回答这个问题:如果相等的对象必须具有相同的哈希码,那么计算哈希码就不应包括任何不用于相等检查的字段。(否则两个对象只是这些字段不同但是仍然有可能会相等，此时他们这两个对象哈希码却会不相同。)所以用于哈希组字段应该相等时使用的字段的子集。默认情况下都使用相同的字段,但有一些细节需要考虑。 一致性首先,有一致性的要求。它应该相当严格。虽然它允许如果一些字段改变对应的哈希码发生变化(对于可变的类是不可避免的)，但是哈希数据结构并不是为这种场景准备的。正如我们以上所见的哈希码用于确定元素的桶。但如果hash-relevant字段发生了改变,并不会重新计算哈希码、也不会更新内部数组。这意味着以后通过相等的对象，甚至同一实例进行查询也会失败，数据结构计算当前的哈希码与之前存储实例计算的哈希码并不一致,并是错误的桶。结论:最好不要使用可变字段计算哈希码! 性能哈希码最终计算的频率与可能调用equals差不多，那么这里将是影响性能的关键部分，因此考虑此部分性能也是非常有意义的。并且与equals相比，优化之后又更大的上升空间。除非使用非常复杂的算法或者涉及非常多的字段，那么计算哈希码的运算成本是微不足道的、同样也是不可避免的。但是也应该考虑是否需要包含所有的字段来进行运算。集合需要特别警惕的对待。以Lists和sets为例，将会包含集合里面的每一个元素来计算哈希码。是否需要调用它们需要具体情况具体分析。如果性能是至关重要的，使用Objects.hash因为需要为varargs创建一个数组也许并不是最好的选择但一般规则优化是适用的:不要过早地!使用一个通用的散列码算法,也许需要放弃集合,只有优化分析显示潜在的改进。 碰撞总是关注性能,这个实现怎么呢?1234@Overridepublic int hashCode() &#123; return 0;&#125; 快是肯定的。相等的对象将具有相同的哈希码。并且,没有可变的字段!但是，我们之前说过的桶呢？！这种方式下所有的实例将会有相同的桶！这将会导致一个链表来包含所有的元素，这样一来将会有非常差的性能。每次调用contains将会触发对整个list线性扫描。我们希望尽可能少的元素在同一个桶!一个算法返回变化多端的哈希码,即使对于非常相似的对象,是一个好的开始。怎样才能达到上面的效果部分取决于选取的字段，我们在计算中包含更多的细节，越有可能获取到不同的哈希码。注意：这个与我们所说的性能是完全相反的。因此，有趣的是，使用过多或者过少的字段都会导致糟糕的性能。防止碰撞的另一部分是使用实际计算散列的算法。 计算Hsah最简单的方法来计算一个字段的哈希码是通过直接调用hashCode，结合的话会自动完成。常见的算法是首先在以任意数量的数值(通常是基本数据类型)反复进行相乘操作再与字段哈希码相加12345int prime = 31;int result = 1;result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());return result; 这可能导致溢出,但是不是特别有问题的,因为他们并没有产生Java异常。 注意,即使是非常良好的的哈希算法也可能因为输入特定的模式的数据有导致频繁碰撞。作为一个简单的例子假设我们会计算点的散列通过增加他们的x和y坐标。当我们处理f(x) = -x线上的点时，线上的点都满足：x + y == 0，将会有大量的碰撞。 但是:我们可以使用一个通用的算法，只到分析表明并不正确，才需要对哈希算法进行修改。 总结我们了解到计算哈希码就是压缩相等的一个整数值：相等的对象必须有相同的哈希码，而出于对性能的考虑：最好是尽可能少的不相等的对象共享相同的哈希码。 这就意味着如果重写了equals方法，那么就必须重写hashCode方法 当实现hashCode 使用与equals中使用的相同的字段(或者equals中使用字段的子集) 最好不要包含可变的字段。 对集合不要考虑调用hashCode 如果没有特殊的输入特定的模式，尽量采用通用的哈希算法 记住hashCode性能,所以除非分析表明必要性，否则不要浪费太多的精力。 首发地址：http://www.codeceo.com/article/java-hashcode-implement.html英文原文：https://www.sitepoint.com/how-to-implement-javas-hashcode-correctly/本文作者：漠北空城","categories":[],"tags":[]},{"title":"LinkedList源码分析","slug":"LinkedList源码分析","date":"2016-06-18T04:09:32.000Z","updated":"2016-07-16T02:08:49.013Z","comments":true,"path":"2016/06/18/LinkedList源码分析/","link":"","permalink":"http://yuechang.github.io/2016/06/18/LinkedList源码分析/","excerpt":"","text":"Java版本：123java version \"1.7.0_79\"Java(TM) SE Runtime Environment (build 1.7.0_79-b15)Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode) LinkedList由双向链表实现。LinkedList主要成员变量： 12345678910111213141516171819202122232425262728transient int size = 0;/** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */transient Node&lt;E&gt; first;/** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */transient Node&lt;E&gt; last;//核心数据结构代码：private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element ; this.next = next ; this.prev = prev ; &#125;&#125; 通过定义的内部类，包括三个成员变量，数据对象，前一个节点对象，以及后一个节点对象。 add()/get()/remove()方法举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125; . * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125; ) */public boolean add(E e ) &#123; linkLast(e); return true ;&#125;/** * Links e as last element. * 首先获得最后一个元素，新建一个节点newNode， * 如果最后一个元素为空，则将newNode赋值给first * 否则将newNode赋值给最后一个元素的next */void linkLast(E e) &#123; final Node&lt;E&gt; l = last ; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l. next = newNode; size++; modCount++;&#125;/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * 检查index合法性，调用node方法 */public E get( int index ) &#123; checkElementIndex(index); return node(index).item ;&#125;/** * Returns the (non -null) Node at the specified element index. * 采用二分，如果index小于size &gt;&gt; 1(size/2),那么将从第一个元素开始往前推 * 否则，从最后一个元素往后推 */Node&lt;E&gt; node(int index ) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index ; i ++) x = x. next; return x ; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index ; i --) x = x. prev; return x ; &#125;&#125;/** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * 检查index合法性，根据index获得对应的Node元素作为参数，调用unlink方法 */public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;/** * Unlinks non -null node x. * 获得Node对象的element，前一个节点prev及后一个节点next * 处理x的prev节点： * 如果移除的元素为首元素(即prev为null)，那么直接将节点next赋给first * 否则，将next赋值给prev.next，并将x.prev置空 * 处理x的next节点： * 如果移除的元素为尾元素(即next为null)，那么直接将节点prev赋值给last * 否则，将prev赋值给next.prev，并将x.next置空 */E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item ; final Node&lt;E&gt; next = x.next ; final Node&lt;E&gt; prev = x.prev ; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next. prev = prev; x.next = null; &#125; x. item = null; size--; modCount++; return element ;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yuechang.github.io/tags/java/"}]},{"title":"ArrayList源码分析","slug":"ArrayList源码分析","date":"2016-06-11T03:16:45.000Z","updated":"2016-07-16T02:08:42.723Z","comments":true,"path":"2016/06/11/ArrayList源码分析/","link":"","permalink":"http://yuechang.github.io/2016/06/11/ArrayList源码分析/","excerpt":"","text":"Java版本：123java version \"1.7.0_79\"Java(TM) SE Runtime Environment (build 1.7.0_79-b15)Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode) ArrayList采用动态数组实现。 ArrayList主要成员变量：123456789101112131415/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == EMPTY_ELEMENTDATA will be expanded to * DEFAULT_CAPACITY when the first element is added. * 底层存储数据的数组 */private transient Object[] elementData;/** * The size of the ArrayList (the number of elements it contains). * 大小 * @serial */private int size; 其中，transient表示： java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 ArrayList扩容核心代码：1234567891011121314151617 /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @paramminCapacity the desired minimum capacity */privatevoid grow(int minCapacity) &#123; // overflow-conscious code intoldCapacity=elementData.length; intnewCapacity=oldCapacity+ (oldCapacity&gt;&gt; 1); if(newCapacity-minCapacity&lt; 0) newCapacity=minCapacity; if(newCapacity-MAX_ARRAY_SIZE&gt; 0) newCapacity=hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData= Arrays.copyOf(elementData,newCapacity); &#125; ArrayList默认初始容量为10，扩容机制：oldCapacity+ (oldCapacity&gt;&gt; 1); （初始容量*1.5），最终的数组复制均是通过System.arraycopy()方法来复制，其中native表示 “A native method is a Java method whose implementation is provided by non-java code.”public static native void arraycopy(Object src,int srcPos,Object dest,int destPos,int length); add()、remove()方法最终均调用System.arraycopy()来实现。 add()/get()/remove()方法举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Appends the specified element to the end of this list. * *@parame element to be appended to this list *@return&lt;tt&gt;true&lt;/tt&gt;(as specified by&#123;@link Collection#add&#125;) */public boolean add(E e) &#123; ensureCapacityInternal(size+ 1); // Increments modCount!! elementData[size++] =e; returntrue; &#125;private void ensureCapacityInternal(int minCapacity) &#123; if(elementData==EMPTY_ELEMENTDATA) &#123; minCapacity= Math.max(DEFAULT_CAPACITY,minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if(minCapacity-elementData.length&gt; 0) grow(minCapacity); &#125;/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * *@paramindex the index of the element to be removed *@returnthe element that was removed from the list *@throwsIndexOutOfBoundsException&#123;@inheritDoc&#125; */publicE remove(int index) &#123; rangeCheck(index); modCount++; EoldValue= elementData(index); intnumMoved=size-index- 1; if(numMoved&gt; 0) System.arraycopy(elementData,index+1,elementData,index, numMoved); elementData[--size] =null;// clear to let GC do its work returnoldValue; &#125;@SuppressWarnings(\"unchecked\") E elementData(int index) &#123; return (E)elementData[index]; &#125;/** * Returns the element at the specified position in this list. * *@param index index of the element to return *@returnthe element at the specified position in this list *@throwsIndexOutOfBoundsException&#123;@inheritDoc&#125; */publicE get(int index) &#123; rangeCheck(index); return elementData(index); &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yuechang.github.io/tags/java/"}]},{"title":"HashMap源码分析","slug":"HashMap源码分析","date":"2016-06-04T02:34:26.000Z","updated":"2016-07-16T02:08:27.849Z","comments":true,"path":"2016/06/04/HashMap源码分析/","link":"","permalink":"http://yuechang.github.io/2016/06/04/HashMap源码分析/","excerpt":"","text":"Java版本：123java version \"1.7.0_79\"Java(TM) SE Runtime Environment (build 1.7.0_79-b15)Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode) HashMap由散列表结构实现。 HashMap 主要成员变量：因子越小，冲突越少。因子越小，越容易触发扩容，从而使每个数组节点上的元素数减少，查找的效率也会提高，但是同时将会消耗不少的空间。因子小，以空间换时间因子大，以时间换空间 12345678910111213141516171819202122232425262728293031323334353637383940/** * An empty table instance to share when the table is not inflated. */static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;/** * The table, resized as necessary. Length MUST Always be a power of two. */transient Entry&lt;K,V&gt;[] table= (Entry&lt;K,V&gt;[]) EMPTY_TABLE;/** * The number of key -value mappings contained in this map. * 大小 */transient int size ;/** * The next size value at which to resize (capacity * load factor). * 阀值 * @serial */// If table == EMPTY_TABLE then this is the initial capacity at which the// table will be created when inflated.int threshold;/** * The load factor for the hash table. * 加载因子 * @serial */final float loadFactor ;/** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection -views of * the HashMap fail -fast. (See ConcurrentModificationException). */transient int modCount ; Entry定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key ; V value; Entry &lt;K,V&gt; next ; int hash ; /** * Creates new entry. */ Entry( int h , K k , V v , Entry &lt;K,V&gt; n ) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key ; &#125; public final V getValue() &#123; return value ; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue ; &#125; /** * 只有当key与value同时相等时，才返回true * */ public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false ; Map.Entry e = (Map.Entry) o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true ; &#125; return false ; &#125; public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects. hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125; /** * This method is invoked whenever the value in an entry is * overwritten by an invocation of put(k,v) for a key k that's already * in the HashMap. */ void recordAccess(HashMap&lt;K,V&gt; m ) &#123; &#125; /** * This method is invoked whenever the entry is * removed from the table. */ void recordRemoval(HashMap&lt;K,V&gt; m ) &#123; &#125; &#125; put()在执行put方法时，会判断key是否已经存入，如果存入，则覆盖之前的值，否则将通过addEntry()方法添加一个Entry对象。addEntry()方法，如果size大于等于阀值(容量*加载因子)并且table[bucketIndex]元素不为空，将会触发扩容，bucketIndex计算结果类似于取余运算。扩容时，将会把table容量扩大一倍，并将之前table中的值，通过transfer方法放入newtable中（重新hash），最后将newtable赋给table。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt; key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key &lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key &lt;/tt&gt;.) */public V put (K key , V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value ); int hash = hash(key); // indexFor函数在下面有详细介绍 int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table [i]; e != null; e = e.next) &#123; Object k; if (e .hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e. value; e. value = value; e.recordAccess( this); return oldValue ; &#125; &#125; modCount++; addEntry( hash, key, value, i); return null ;&#125;/** * Adds a new entry with the specified key, value and hash code to * the specified bucket. It is the responsibility of this * method to resize the table if appropriate. * * Subclass overrides this to alter the behavior of put method. * 容量扩大一倍，因为hashmap的容量总是为2的次方 */void addEntry( int hash , K key , V value , int bucketIndex) &#123; if ((size &gt;= threshold ) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table. length); hash = ( null != key ) ? hash(key) : 0; bucketIndex = indexFor(hash, table. length); &#125; createEntry( hash, key, value, bucketIndex);&#125;/** * Rehashes the contents of this map into a new array with a * larger capacity. This method is called automatically when the * number of keys in this map reaches its threshold. * * If current capacity is MAXIMUM_CAPACITY, this method does not * resize the map, but sets threshold to Integer.MAX_VALUE. * This has the effect of preventing future calls. * * @param newCapacity the new capacity, MUST be a power of two; * must be greater than current capacity unless current * capacity is MAXIMUM_CAPACITY (in which case value * is irrelevant). */void resize(int newCapacity ) &#123; Entry[] oldTable = table; int oldCapacity = oldTable .length ; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min( newCapacity * loadFactor , MAXIMUM_CAPACITY + 1);&#125;/** * Transfers all entries from current table to newTable. * 如果newTable[i]不为空，那么将newTable[i]作为新插入元素的下一个元素， * 即插入元素插入到链表的最前端。 */void transfer(Entry[] newTable, boolean rehash ) &#123; int newCapacity = newTable .length ; for (Entry&lt;K,V&gt; e : table ) &#123; while(null != e ) &#123; Entry&lt;K,V&gt; next = e. next; if (rehash ) &#123; e. hash = null == e .key ? 0 : hash(e.key); &#125; int i = indexFor( e. hash, newCapacity); e. next = newTable[i]; // 链式 newTable[i] = e; e = next; &#125; &#125;&#125;/** * Returns index for hash code h. * length为2的次方，那么length-1二进制则为111111...形式； * &amp;运算：1&amp;1=1,1&amp;0=0,0&amp;1=0，0&amp;0=0 * 当h小于length时，结果即为h，当h大于length时，最后结果也将小于length， * 个人理解结果为h%length，效率却高于h%length */static int indexFor(int h , int length) &#123; // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\"; return h &amp; (length -1);&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yuechang.github.io/tags/java/"}]},{"title":"Eclipse快速打开文件目录插件——OpenExplorer","slug":"Eclipse快速打开文件目录插件——OpenExplorer","date":"2016-05-26T08:09:53.000Z","updated":"2017-01-20T11:42:55.449Z","comments":true,"path":"2016/05/26/Eclipse快速打开文件目录插件——OpenExplorer/","link":"","permalink":"http://yuechang.github.io/2016/05/26/Eclipse快速打开文件目录插件——OpenExplorer/","excerpt":"","text":"Eclipse快速打开文件目录插件——Open Explorer 下载地址：OpenExplorer下载 将下载的jar包放入到Eclipse下的dropins目录，重启Eclipse，插件就能生效了。","categories":[],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://yuechang.github.io/tags/Eclipse/"}]},{"title":"最后的武士观后感","slug":"最后的武士观后感","date":"2016-01-03T07:26:12.000Z","updated":"2016-01-06T13:35:48.000Z","comments":true,"path":"2016/01/03/最后的武士观后感/","link":"","permalink":"http://yuechang.github.io/2016/01/03/最后的武士观后感/","excerpt":"","text":"最后的武士观后感——人生应该追求什么？！12345They say Japan was made by a sword.They say the old gods dipped a coralblade into ocean,and when they pulled it out,four perfect drops dellback into the sea,and those drops became the islands of Japan.I sayJapan was made by a handful of brave men,warriors willing to give theirlives,for what seems to have become a forgotten word:Honor. 独白中提到:日本由少数武士所创造，这些武士愿意为了一个早被遗忘的理念——荣耀，牺牲生命。这些武士所信仰的荣耀，也就是武士道。那么日本武士的代表：Katsumoto一生在追求什么呢？！我觉得Katsumoto一生都在追求正是：侍。 武士家族从小就开始培养“侍”这个观念，可以从影片中Higen的学习中看出，Higen练习书法，写过一个未完成的“侍”，我觉得如果不对“侍”这种观念非常重视，练习书法的时候没有必要写这个字，更没有必要在Nathan Algren和离开村庄的时候，特意送一个写的“侍”字作为礼物给Nathan。而侍到底是什么呢？！影片中有提到，即服侍他人！而这一点，在Taka身上表现得尤为突出，她的丈夫被Nathan杀了，她也服从她哥哥的安排，细心照顾杀夫之人Nathan，侍的观念得到淋漓尽致的体现，还有一点就是在Taka做家务的时候，很吃力的在搬一篓子米，Nathan刚好遇到，帮她把米搬到厨房，这个时候，Taka说了一句话，日本男人从来不做家务活，可见服侍他人的观念早已在妇女心中根深蒂固。而在一个家庭，妇女和小孩都已经对这侍非常认同，那么小孩子长大之后，会如何看待这侍呢？！毫无悬念，将更加深信不疑，以至于认为牺牲生命也是理所当然！一代一代循环扩大，民族甚至整个国家都有这样的观念！ 而对于Nathan，他的一生在追求什么呢？！看起来，他并没有这么高尚，他一直都在满足自身的需求。在影片的前段，他为了钱而东渡太平洋来到日本，之后随着对这些武士逐渐熟悉，武士精神的了解，发现原本只能借助酒精来麻痹自己，后面发现这种精神粮食竟然可以让自己平静下来！甚至可以开导自己，让自己走出痛苦的枷锁，达到内心平静的境界！以至于最后，Nathan也是回到了这个让他内心平静的神奇的小村庄，通过一事一物来感受美好的生命！ 我觉得只有满足了自己的需求才能更好的服侍他人！正如当你不断追求卓越，成功就会与你不期而遇也是同一个道理！","categories":[],"tags":[{"name":"个人感想","slug":"个人感想","permalink":"http://yuechang.github.io/tags/个人感想/"}]},{"title":"观察者设计模式及java Demo","slug":"观察者设计模式及java-Demo","date":"2015-11-19T09:35:41.000Z","updated":"2016-05-14T15:49:57.191Z","comments":true,"path":"2015/11/19/观察者设计模式及java-Demo/","link":"","permalink":"http://yuechang.github.io/2015/11/19/观察者设计模式及java-Demo/","excerpt":"","text":"观察者设计模式 1、主题对象管理着某些数据；2、当主题内的数据改变就会通知观察者(一旦数据发生改变，新的数据会以某种形式送到观察者手上)；3、观察者已经订阅(注册)主题以便在主题数据改变时能够收到更新； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * @Title: ObserverTest.java * @Package com.primeton.test * @Description: TODO(用一句话描述该文件做什么) * @date 2015年11月6日 下午11:04:07 * @version V1.0 */package com.primeton.test;import java.util.Observable;import java.util.Observer;/** * @ClassName: ObserverTest * @Description: TODO(这里用一句话描述这个类的作用) * @author yuechang * @date 2015年11月6日 下午11:04:07 */public class Test &#123; public static void main(String[] args) &#123; School school = new School(\"娄底师专\"); Student studentA = new Student(school.getSchoolName(), \"A\"); Student studentB = new Student(school.getSchoolName(), \"B\"); school.addObserver(studentA); school.addObserver(studentB); System.out.println(school); System.out.println(studentA); System.out.println(studentB); // 学校改名了 school.setSchoolName(\"湖南人文科技学院\"); school.setChanged(); school.notifyObservers(school); System.out.println(school); System.out.println(studentA); System.out.println(studentB); &#125;&#125;class School extends Observable &#123; private String schoolName; public School() &#123; &#125; /** * @param schoolName */ public School(String schoolName) &#123; super(); this.schoolName = schoolName; &#125; public String getSchoolName() &#123; return schoolName; &#125; public void setSchoolName(String schoolName) &#123; this.schoolName = schoolName; &#125; @Override public String toString() &#123; return \"School [schoolName=\" + schoolName + \"]\"; &#125; @Override protected synchronized void setChanged() &#123; super.setChanged(); &#125;&#125;class Student implements Observer &#123; private String studentName; private String schoolName; public Student() &#123; &#125; /** * @param studentName * @param schoolName */ public Student(String schoolName, String studentName) &#123; super(); this.studentName = studentName; this.schoolName = schoolName; &#125; public String getStudentName() &#123; return studentName; &#125; public void setStudentName(String studentName) &#123; this.studentName = studentName; &#125; public String getSchoolName() &#123; return schoolName; &#125; public void setSchoolName(String schoolName) &#123; this.schoolName = schoolName; &#125; @Override public void update(Observable o, Object arg) &#123; if (arg instanceof School) &#123; this.schoolName = ((School) arg).getSchoolName(); &#125; &#125; @Override public String toString() &#123; return \"Student [studentName=\" + studentName + \", schoolName=\" + schoolName + \"]\"; &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yuechang.github.io/tags/设计模式/"}]},{"title":"ShardedJedisPool详解","slug":"ShardedJedisPool详解","date":"2015-10-21T09:08:15.000Z","updated":"2015-11-03T12:22:42.000Z","comments":true,"path":"2015/10/21/ShardedJedisPool详解/","link":"","permalink":"http://yuechang.github.io/2015/10/21/ShardedJedisPool详解/","excerpt":"","text":"ShardedJedisPool详解ShardedJedisPool类有四个构造函数123456789101112131415161718public ShardedJedisPool(final GenericObjectPoolConfig poolConfig, List&lt;JedisShardInfo&gt; shards) &#123; this(poolConfig, shards, Hashing.MURMUR_HASH);&#125;public ShardedJedisPool(final GenericObjectPoolConfig poolConfig, List&lt;JedisShardInfo&gt; shards, Hashing algo) &#123; this(poolConfig, shards, algo, null);&#125;public ShardedJedisPool(final GenericObjectPoolConfig poolConfig, List&lt;JedisShardInfo&gt; shards, Pattern keyTagPattern) &#123; this(poolConfig, shards, Hashing.MURMUR_HASH, keyTagPattern);&#125;public ShardedJedisPool(final GenericObjectPoolConfig poolConfig, List&lt;JedisShardInfo&gt; shards, Hashing algo, Pattern keyTagPattern) &#123; super(poolConfig, new ShardedJedisFactory(shards, algo, keyTagPattern));&#125; 其实,最后都是调用父类的构造函数1super(poolConfig, new ShardedJedisFactory(shards, algo, keyTagPattern)); 输入参数说明：1234567final GenericObjectPoolConfig poolConfig：pool的一些设置（maxTotal、maxIdle、minIdle）List&lt;JedisShardInfo&gt; shards：为Redis实例的IP、端口以及超时时间等信息Hashing algo：根据Key计算hash值，从而决定具体存入那个Redis实例Pattern keyTagPattern：Key标签模式，默认是取&#123;&#125;中内容去计算对应Hash值，当key='&#123;key1_0&#125;_0_0'时，此时将根据’key1_0'来计算对应hash值，而不是根据&#123;key1_0&#125;_0_0来计算hash值，从而决定将存入到哪个Redis实例中，如果需要将数据进行排序，将要利用这个构造函数，因为只有将需要排序的数据存入同一个Redis实例中，排序才是准确的。","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yuechang.github.io/tags/redis/"}]},{"title":"MISCONF Redis is configured to save RDB snapshots","slug":"MISCONF-Redis-is-configured-to-save-RDB-snapshots","date":"2015-10-15T10:14:44.000Z","updated":"2015-10-15T15:59:18.000Z","comments":true,"path":"2015/10/15/MISCONF-Redis-is-configured-to-save-RDB-snapshots/","link":"","permalink":"http://yuechang.github.io/2015/10/15/MISCONF-Redis-is-configured-to-save-RDB-snapshots/","excerpt":"","text":"MISCONF Redis is configured to save RDB snapshotsRedis使用过程中报错，报错信息如下：123(error) MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error. 解释：Redis配置去保存RDB快照，但是目前无法保存到磁盘。修改数据命令无效。错误详情请查看redis日志。 没有看Redis logs前，通过关键搜索这个问题，网上建议”config set stop-writes-on-bgsave-error no”,于是抱着试试看的心理，结果确实还能行。这样设置表示bgsave出现错误的时候停止写操作，可能会影响数据保存，只是忽略的错误。1redis 192.168.161.253:6379&gt; config set stop-writes-on-bgsave-error no 可惜好景不长，过一段时间再次操作，发现问题依旧。于是继续搜索，一哥们说，应该在/etc/sysctl.conf 添加一项 ‘vm.overcommit_memory = 1’ ，然后重启（或者运行命令’sysctl vm.overcommit_memory=1’ ）使其生效。）继续尝试，发现问题还是存在。。。overcommit_memory说明12345overcommit_memory文件指定了内核针对内存分配的策略，其值可以是0、1、2。 0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许； 否则，内存申请失败，并把错误返回给应用进程。 1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。2， 表示内核允许分配超过所有物理内存和交换空间总和的内存 本来想偷懒，最后还是不得不做，设置日志文件logfile，看错误日志：12346390:M 14 Oct 10:24:10.056 * 1 changes in 900 seconds. Saving...6390:M 14 Oct 10:24:10.057 * Background saving started by pid 70857085:C 14 Oct 10:24:10.058 # Failed opening .rdb for saving:Permission denied6390:M 14 Oct 10:24:10.058 * Background saving error 使用关键字Failed opening .rdb for saving:Permission denied重新搜索，得到结论：权限不足。首先，检查redis安装目录，本次操作用户是否有读写权限，最好修改为所有者。然后，检查redis.conf文件里面的dir ./，./表示当前目录，检查当前目录是否有读写权限。 ./目录说明1linux-dmvx:/usr/redis-3.0.1/src # ./redis-server /usr/redis-3.0.1/redis.conf 此时的./表示：/usr/redis-3.0.1/src 1linux-dmvx:/ # /usr/redis-3.0.1/src/redis-server /usr/redis-3.0.1/redis.conf 此时的./表示：根目录只要保证这两个目录对于当前用户均有读写权限，那么就不会再有这个错误：Failed opening .rdb for saving:Permission denied 另附Suse 11 Sp2创建用户以及授权的命令：123456新建用户groupadd redisMgr #添加组redisMgruseradd -g redisMgr redis #新建用户redis，指定为redisMgr组password redis #修改redis用户密码redis变更文件夹权限chown redis:redisMgr /usr/redis-3.0.1 #chown 用户名:组名 路径","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yuechang.github.io/tags/redis/"}]},{"title":"Jsqlparser使用","slug":"Jsqlparser使用","date":"2015-10-09T03:43:54.000Z","updated":"2015-10-09T08:05:38.000Z","comments":true,"path":"2015/10/09/Jsqlparser使用/","link":"","permalink":"http://yuechang.github.io/2015/10/09/Jsqlparser使用/","excerpt":"","text":"Java SQL语句解析——Jsqlparser开源项目项目需要解析SQL语句获得表名以及where中的字段，自认为自己写代码来解析比较复杂也就在网上找相关的资料，最后找到这个开源项目JSqlparser. jar包jsqlparser-0.9.1.jar github项目jsqlparser-github sourceforge上项目介绍jsqlparser-sourceforge 相关资料准备完成，具体代码如下： java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.primeton.sqlparser;import java.io.StringReader;import net.sf.jsqlparser.JSQLParserException;import net.sf.jsqlparser.expression.BinaryExpression;import net.sf.jsqlparser.expression.Expression;import net.sf.jsqlparser.parser.CCJSqlParserManager;import net.sf.jsqlparser.schema.Column;import net.sf.jsqlparser.statement.Statement;import net.sf.jsqlparser.statement.update.Update;/** * @ClassName: JsqlparserDemo * @Description: TODO(这里用一句话描述这个类的作用) * @author yuechang yuechang5@hotmail.com * @date 2015年9月2日 上午11:40:59 */public class JsqlparserDemo &#123; public static void main(String[] args) throws JSQLParserException &#123; demo(); &#125; public static void demo() throws JSQLParserException&#123; CCJSqlParserManager pm = new CCJSqlParserManager(); StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(\"update ac_operator op \"); stringBuffer.append(\"set op.errcount=(\"); stringBuffer.append(\"(select case when op1.errcount is null then 0 else op1.errcount end as errcount \"); stringBuffer.append(\"from ac_operator op1 \"); stringBuffer.append(\"where op1.loginname = '中国' )+1\"); stringBuffer.append(\"),lastlogin='中国' \"); stringBuffer.append(\"where PROCESS_ID=\"); stringBuffer.append(\"(select distinct g.id from tempTable g where g.ID='中国')\"); stringBuffer.append(\"and columnName2 = '890' and columnName3 = '678' and columnName4 = '456'\"); Statement statement = pm.parse(new StringReader(stringBuffer.toString())); if (statement instanceof Update) &#123; //获得Update对象 Update updateStatement = (Update) statement; //获得表名 System.out.println(\"table:\"+updateStatement.getTable().getName()); //获得where条件表达式 Expression where = updateStatement.getWhere(); //初始化接收获得到的字段信息 StringBuffer allColumnNames = new StringBuffer(); //BinaryExpression包括了整个where条件， //例如：AndExpression/LikeExpression/OldOracleJoinBinaryExpression if(where instanceof BinaryExpression)&#123; allColumnNames = getColumnName((BinaryExpression)(where),allColumnNames); System.out.println(\"allColumnNames:\"+allColumnNames.toString()); &#125; &#125; &#125; /** * 获得where条件字段中列名，以及对应的操作符 * @Title: getColumnName * @Description: TODO(这里用一句话描述这个方法的作用) * @param @param expression * @param @param allColumnNames * @param @return 设定文件 * @return StringBuffer 返回类型 * @throws */ private static StringBuffer getColumnName(Expression expression,StringBuffer allColumnNames) &#123; String columnName = null; if(expression instanceof BinaryExpression)&#123; //获得左边表达式 Expression leftExpression = ((BinaryExpression) expression).getLeftExpression(); //如果左边表达式为Column对象，则直接获得列名 if(leftExpression instanceof Column)&#123; //获得列名 columnName = ((Column) leftExpression).getColumnName(); allColumnNames.append(columnName); allColumnNames.append(\":\"); //拼接操作符 allColumnNames.append(((BinaryExpression) expression).getStringExpression()); //allColumnNames.append(\"-\"); &#125; //否则，进行迭代 else if(leftExpression instanceof BinaryExpression)&#123; getColumnName((BinaryExpression)leftExpression,allColumnNames); &#125; //获得右边表达式，并分解 Expression rightExpression = ((BinaryExpression) expression).getRightExpression(); if(rightExpression instanceof BinaryExpression)&#123; Expression leftExpression2 = ((BinaryExpression) rightExpression).getLeftExpression(); if(leftExpression2 instanceof Column)&#123; //获得列名 columnName = ((Column) leftExpression2).getColumnName(); allColumnNames.append(\"-\"); allColumnNames.append(columnName); allColumnNames.append(\":\"); //获得操作符 allColumnNames.append(((BinaryExpression) rightExpression).getStringExpression()); &#125; &#125; &#125; return allColumnNames; &#125;&#125; 运行结果12tableName:ac_operatorallColumnNames:PROCESS_ID:=-columnName2:=-columnName3:=-columnName4:=","categories":[],"tags":[]},{"title":"一致性Hash算法及Java实现","slug":"一致性Hash算法及Java实现","date":"2015-07-25T07:30:38.000Z","updated":"2015-09-16T14:25:56.000Z","comments":true,"path":"2015/07/25/一致性Hash算法及Java实现/","link":"","permalink":"http://yuechang.github.io/2015/07/25/一致性Hash算法及Java实现/","excerpt":"","text":"1、一致性Hash简介一致性哈希算法在1997年由麻省理工学院提出(参见扩展阅读[1])，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得DHT可以在P2P环境中真正得到应用。 2、评价一致性Hash算法的标准一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个方面： 2.1、平衡性(Balance)平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。 2.2、单调性(Monotonicity)单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 2.3、分散性(Spread)在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 2.4、负载(Load)负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。 3、Java实现关键代码关键代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//构造函数public RedisConsistentHash(HashFunction hashFunction, int numberOfReplicas,Collection&lt;T&gt; nodes) &#123; this.hashFunction = hashFunction; this.numberOfReplicas = numberOfReplicas; for (T node : nodes) &#123; add(node); &#125;&#125;/** * 添加节点信息 * @param node */public void add(T node) &#123; for (int i = 0; i &lt; numberOfReplicas; i++) &#123; circle.put(hashFunction.hash(node.toString() + i), node); &#125;&#125;/** * 移除节点信息 * @param node */public void remove(T node) &#123; for (int i = 0; i &lt; numberOfReplicas; i++) &#123; circle.remove(hashFunction.hash(node.toString() + i)); &#125;&#125;/** * 根据key获得一致性hash中的值， * 当值不存在时，返回circle.tailMap的首个元素或者circle的首个元素 * @param key * @return */public T get(Object key) &#123; if (circle.isEmpty()) &#123; return null; &#125; int hash = hashFunction.hash(key); if (!circle.containsKey(hash)) &#123; SortedMap&lt;Integer, T&gt; tailMap = circle.tailMap(hash); hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey(); &#125; return circle.get(hash);&#125;public static class HashFunction &#123; public int hash(Object key) &#123; // md5加密后，hashcode return MD5.MD5Encode(key.toString()).hashCode(); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yuechang.github.io/tags/java/"}]},{"title":"积微","slug":"积微","date":"2015-07-24T14:31:20.000Z","updated":"2015-09-16T13:40:20.000Z","comments":true,"path":"2015/07/24/积微/","link":"","permalink":"http://yuechang.github.io/2015/07/24/积微/","excerpt":"","text":"荀子·强国篇积微，月不胜日，时不胜月，岁不胜时。凡人好敖慢小事，大事至，然后兴之务之，如是，则常不胜夫敦比于小事者矣。是何也？则小事之至也数，其县日也博，其为积也大；大事之至也希，其县日也浅，其为积也小。故善日者王，善时者霸，补漏者危，大荒者亡。故王者敬日，霸者敬时，仅存之国危而后戚之，亡国至亡而后知亡，至死而后知死。亡国之祸败，不可胜悔也；霸者之善箸焉，可以时托也；王者之功名，不可胜日志也。财物货宝以大为重，政教功名反是，能积微者速成。《诗》曰：“德 如毛，民鲜克举之。”此之谓也。","categories":[],"tags":[]},{"title":"java.lang.VerifyError错误","slug":"java-lang-VerifyError错误","date":"2015-07-14T03:33:16.000Z","updated":"2015-09-16T14:25:30.000Z","comments":true,"path":"2015/07/14/java-lang-VerifyError错误/","link":"","permalink":"http://yuechang.github.io/2015/07/14/java-lang-VerifyError错误/","excerpt":"","text":"1、错误消息12345java.lang.VerifyError: (class: cn/search/PageManager, method: &lt;init&gt; signature: (Ljava/lang/String;)V) Bad type in putfield/putstatic cn.search.servlet.SearchController.doPost(SearchController.java:67) cn.search.servlet.SearchController.doGet(SearchController.java:35) javax.servlet.http.HttpServlet.service(HttpServlet.java:690) javax.servlet.http.HttpServlet.service(HttpServlet.java:803) 2、解决办法仔细查找代码，发现并没有问题，各种百度之后发现：是jar包冲突而引起的问题。可能出现冲突的情况：1、存在不同版本的jar包；2、webapp目录下和tomcat的lib目录下jar包重复了；","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yuechang.github.io/tags/java/"}]},{"title":"ConcurrentModificationException异常总结-多线程方式","slug":"ConcurrentModificationException异常总结-多线程方式","date":"2015-07-12T01:37:08.000Z","updated":"2015-09-16T13:44:04.000Z","comments":true,"path":"2015/07/12/ConcurrentModificationException异常总结-多线程方式/","link":"","permalink":"http://yuechang.github.io/2015/07/12/ConcurrentModificationException异常总结-多线程方式/","excerpt":"","text":"1、多线程方式发生异常举例1.1、java代码如下：12345678910111213141516171819202122232425262728293031final List&lt;String&gt; myList = createTestData();new Thread(new Runnable() &#123; @Override public void run() &#123; for (String string : myList) &#123; System.out.println(\"遍历集合 value = \" + string); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;).start();new Thread(new Runnable() &#123; @Override public void run() &#123; for (Iterator&lt;String&gt; it = myList.iterator(); it.hasNext();) &#123; String value = it.next(); System.out.println(\"删除元素 value = \" + value); if (value.equals(\"3\")) &#123; it.remove(); &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;).start(); 1.2、异常信息打印如下：12345678910111213遍历集合 value = 1删除元素 value = 1删除元素 value = 2遍历集合 value = 2遍历集合 value = 3删除元素 value = 3删除元素 value = 4Exception in thread \"Thread-0\" java.util.ConcurrentModificationException at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372) at java.util.AbstractList$Itr.next(AbstractList.java:343) at com.primeton.test.Test$1.run(Test.java:119) at java.lang.Thread.run(Thread.java:619)删除元素 value = 5 当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。说明以上办法在同一个线程执行的时候是没问题的，但是在异步情况下依然可能出现异常。 2、解决办法2.1、采用以下代码，将不会出现之前的异常12345678910111213141516171819202122232425262728293031323334353637final List&lt;String&gt; myList = new CopyOnWriteArrayList&lt;String&gt;();myList.add(\"1\");myList.add(\"2\");myList.add(\"3\");myList.add(\"4\");myList.add(\"5\");new Thread(new Runnable() &#123; @Override public void run() &#123; for (String string : myList) &#123; System.out.println(\"遍历集合 value = \" + string); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;).start();new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; myList.size(); i++) &#123; String value = myList.get(i); System.out.println(\"删除元素 value = \" + value); if (value.equals(\"3\")) &#123; myList.remove(value); i--; // 注意 &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;).start(); 2.2、输出结果12345678910遍历集合 value = 1删除元素 value = 1遍历集合 value = 2删除元素 value = 2遍历集合 value = 3删除元素 value = 3遍历集合 value = 4删除元素 value = 4遍历集合 value = 5删除元素 value = 5 3、相关总结1、使用Collections.synchornizedXxx方法，获得线程安全对象2、使用java.util.concurrent/java.util.concurrent.atomic并发编程对象开发另附java中线程安全的类：HashTable、Vector、Stack、StringBuffer等","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yuechang.github.io/tags/java/"}]},{"title":"redis.conf配置文件详解","slug":"redis-conf配置文件详解","date":"2015-07-08T03:49:04.000Z","updated":"2015-09-16T13:43:06.000Z","comments":true,"path":"2015/07/08/redis-conf配置文件详解/","link":"","permalink":"http://yuechang.github.io/2015/07/08/redis-conf配置文件详解/","excerpt":"","text":"redis配置文件redis.conf详细说明 1、daemonize123456# By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.# Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程（守护进程# daemon）是指在UNIX或其他多任务操作系统中在后台执行的电脑程序，并不会接受电脑用户的直接操# 控。）daemonize no 2、pidfile12345# When running daemonized, Redis writes a pid file in /var/run/redis.pid by# default. You can specify a custom pid file location here.# 当 Redis 以守护进程的方式运行的时候,Redis 默认会把 pid 文件放在/var/run/redis.pid,# 你可以配置到其他地址。当运行多个 redis 服务时,需要指定不同的 pid 文件和端口# pidfile /var/run/redis.pid 3、port1234# Accept connections on the specified port, default is 6379.# If port 0 is specified Redis will not listen on a TCP socket.# 端口没什么好说的port 6379 4、bind1234# If you want you can bind a single interface, if the bind option is not# specified all the interfaces will listen for incoming connections.# 指定Redis可接收请求的IP地址,不设置将处理所有请求,建议生产环境中设置# bind 127.0.0.1 5、timeout123# Close the connection after a client is idle for N seconds (0 to disable)# 客户端连接的超时时间,单位为秒,超时后会关闭连接timeout 0 6、logfile12345# Specify the log file name. Also 'stdout' can be used to force# Redis to log on the standard output. Note that if you use standard# output for logging but daemonize, logs will be sent to /dev/null# 配置 log 文件地址,默认打印在命令行终端的窗口上logfile stdout 7、databases12345# Set the number of databases. The default database is DB 0, you can select# a different one on a per-connection basis using SELECT &lt;dbid&gt; where# dbid is a number between 0 and 'databases'-1# 设置数据库的个数,可以使用 SELECT &lt;dbid&gt;命令来切换数据库。默认使用的数据库是 0databases 16 8、save123456789101112131415161718192021## Save the DB on disk:## save &lt;seconds&gt; &lt;changes&gt;## Will save the DB if both the given number of seconds and the given# number of write operations against the DB occurred.## In the example below the behaviour will be to save:# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changed## Note: you can disable saving at all commenting all the \"save\" lines.# 设置 Redis 进行数据库镜像的频率。# 900秒之内有1个keys发生变化时# 30秒之内有10个keys发生变化时# 60秒之内有10000个keys发生变化时save 900 1save 300 10save 60 10000 9、rdbcompression123456# Compress string objects using LZF when dump .rdb databases?# For default that's set to 'yes' as it's almost always a win.# If you want to save some CPU in the saving child set it to 'no' but# the dataset will likely be bigger if you have compressible values or keys.# 在进行镜像备份时,是否进行压缩rdbcompression yes 10、dbfinename123# The filename where to dump the DB#镜像备份文件的文件名dbfilename dump.rdb 11、dir123456789101112# The working directory.## The DB will be written inside this directory, with the filename specified# above using the 'dbfilename' configuration directive.# # Also the Append Only File will be created inside this directory.# # Note that you must specify a directory here, not a file name.# 数据库镜像备份的文件放置的路径。这里的路径跟文件名要分开配置是因为 Redis 在进行备份时,# 先会将当前数据库的状态写入到一个临时文件中,等备份完成时,再把该该临时文件替换为上面所指# 定的文件,而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中dir ./ 12、slaveof123456# Master-Slave replication. Use slaveof to make a Redis instance a copy of# another Redis server. Note that the configuration is local to the slave# so for example it is possible to configure the slave to save the DB with a# different interval, or to listen to another port, and so on.# 设置该数据库为其他数据库的从数据库# slaveof &lt;masterip&gt; &lt;masterport&gt; 13、masterauth123456# If the master is password protected (using the \"requirepass\" configuration# directive below) it is possible to tell the slave to authenticate before# starting the replication synchronization process, otherwise the master will# refuse the slave request.# 指定与主数据库连接时需要的密码验证# masterauth &lt;master-password&gt; 14、requirepass123456789101112131415# Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other# commands. This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).# # Warning: since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.# 设置客户端连接后进行任何其他指定前需要使用的密码。# 警告:redis速度相当快,一个外部的用户可以在一秒钟进行150K次的密码尝试,# 你需要指定非常非常强大的密码来防止暴力破解。# requirepass foobared 15、maxclient12345678# Set the max number of connected clients at the same time. By default there# is no limit, and it's up to the number of file descriptors the Redis process# is able to open. The special value '0' means no limits.# Once the limit is reached Redis will close all the new connections sending# an error 'max number of clients reached'.# 限制同时连接的客户数量。当连接数超过这个值时,# redis 将不再接收其他连接请求,客户端尝试连接时将收到 error 信息# maxclients 128 16、maxmemory123456789101112131415161718192021222324252627282930# Don't use more memory than the specified amount of bytes.# When the memory limit is reached Redis will try to remove keys# accordingly to the eviction policy selected (see maxmemmory-policy).## If Redis can't remove keys according to the policy, or if the policy is# set to 'noeviction', Redis will start to reply with errors to commands# that would use more memory, like SET, LPUSH, and so on, and will continue# to reply to read-only commands like GET.## This option is usually useful when using Redis as an LRU cache, or to set# an hard memory limit for an instance (using the 'noeviction' policy).## WARNING: If you have slaves attached to an instance with maxmemory on,# the size of the output buffers needed to feed the slaves are subtracted# from the used memory count, so that network problems / resyncs will# not trigger a loop where keys are evicted, and in turn the output# buffer of slaves is full with DELs of keys evicted triggering the deletion# of more keys, and so forth until the database is completely emptied.## In short… if you have slaves attached it is suggested that you set a lower# limit for maxmemory so that there is some free RAM on the system for slave# output buffers (but this is not needed if the policy is 'noeviction').# 设置redis能够使用的最大内存。# 当内存满了的时候,如果还接收到set命令,redis将先尝试剔除设置过expire信息的key,# 而不管该key的过期时间还没有到达。# 在删除时,将按照过期时间进行删除,最早将要被过期的key将最先被删除。# 如果带有expire信息的key都删光了,那么将返回错误。# 这样,redis将不再接收写请求,只接收get请求。# maxmemory的设置比较适合于把redis当作于类似memcached 的缓存来使用# maxmemory &lt;bytes&gt; 17、appendonly12345678910111213141516171819202122# By default Redis asynchronously dumps the dataset on disk. If you can live# with the idea that the latest records will be lost if something like a crash# happens this is the preferred way to run Redis. If instead you care a lot# about your data and don't want to that a single record can get lost you should# enable the append only mode: when this mode is enabled Redis will append# every write operation received in the file appendonly.aof. This file will# be read on startup in order to rebuild the full dataset in memory.## Note that you can have both the async dumps and the append only file if you# like (you have to comment the \"save\" statements above to disable the dumps).# Still if append only mode is enabled Redis will load the data from the# log file at startup ignoring the dump.rdb file.## IMPORTANT: Check the BGREWRITEAOF to check how to rewrite the append# log file in background when it gets too big.# 默认情况下,redis会在后台异步的把数据库镜像备份到磁盘,但是该备份是非常耗时的,# 而且备份也不能很频繁,如果发生诸如拉闸限电、拔插头等状况,那么将造成比较大范围的数据丢失。# 所以redis提供了另外一种更加高效的数据库备份及灾难恢复方式。# 开启append only模式之后,redis会把所接收到的每一次写操作请求都追加到appendonly.aof 文件中,# 当redis重新启动时,会从该文件恢复出之前的状态。但是这样会造成 appendonly.aof 文件过大,# 所以redis还支持了BGREWRITEAOF 指令,对appendonly.aof进行重新整理appendonly no 18、appendfsync123456789101112131415161718192021222324# The fsync() call tells the Operating System to actually write data on disk# instead to wait for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP.## Redis supports three different modes:## no: don't fsync, just let the OS flush the data when it wants. Faster.# always: fsync after every write to the append only log . Slow, Safest.# everysec: fsync only if one second passed since the last fsync. Compromise.## The default is \"everysec\" that's usually the right compromise between# speed and data safety. It's up to you to understand if you can relax this to# \"no\" that will will let the operating system flush the output buffer when# it wants, for better performances (but if you can live with the idea of# some data loss consider the default persistence mode that's snapshotting),# or on the contrary, use \"always\" that's very slow but a bit safer than# everysec.## If unsure, use \"everysec\".# 设置对 appendonly.aof 文件进行同步的频率。# always 表示每次有写操作都进行同步,everysec表示对写操作进行累积,每秒同步一次。# appendfsync alwaysappendfsync everysec# appendfsync no 19、vm-enabled123456789101112131415# Virtual Memory allows Redis to work with datasets bigger than the actual# amount of RAM needed to hold the whole dataset in memory.# In order to do so very used keys are taken in memory while the other keys# are swapped into a swap file, similarly to what operating systems do# with memory pages.## To enable VM just set 'vm-enabled' to yes, and set the following three# VM parameters accordingly to your needs.# 是否开启虚拟内存支持。因为redis 是一个内存数据库,而且当内存满的时候,无法接收新的写请求,# 所以在redis2.0中,提供了虚拟内存的支持。# 但是需要注意的是,redis中,所有的key都会放在内存中,在内存不够时,只会把value值放入交换区。# 这样保证了虽然使用虚拟内存,但性能基本不受影响,# 同时,你需要注意的是你要把vm-max-memory设置到足够来放下你的所有的keyvm-enabled no# vm-enabled yes 20、vm-swap-file12345678910111213# This is the path of the Redis swap file. As you can guess, swap files# can&apos;t be shared by different Redis instances, so make sure to use a swap# file for every redis process you are running. Redis will complain if the# swap file is already in use.## The best kind of storage for the Redis swap file (that&apos;s accessed at random) # is a Solid State Disk (SSD).## *** WARNING *** if you are using a shared hosting the default of putting# the swap file under /tmp is not secure. Create a dir with access granted# only to Redis user and configure Redis to create the swap file there.# 设置虚拟内存的交换文件路径vm-swap-file /tmp/redis.swap 21、vm-max-memory123456789101112# vm-max-memory configures the VM to use at max the specified amount of# RAM. Everything that deos not fit will be swapped on disk *if* possible, that# is, if there is still enough contiguous space in the swap file.## With vm-max-memory 0 the system will swap everything it can. Not a good# default, just specify the max amount of RAM you can in bytes, but it's# better to leave some margin. For instance specify an amount of RAM# that's more or less between 60 and 80% of your free RAM.# 这里设置开启虚拟内存之后,redis将使用的最大物理内存的大小。# 默认为0,redis将把他所有的能放到交换文件的都放到交换文件中,以尽量少的使用物理内存。# 在生产环境下,需要根据实际情况设置该值,最好不要使用默认的 0vm-max-memory 0 22、vm-page-size123456789101112# Redis swap files is split into pages. An object can be saved using multiple# contiguous pages, but pages can't be shared between different objects.# So if your page is too big, small objects swapped out on disk will waste# a lot of space. If you page is too small, there is less space in the swap# file (assuming you configured the same number of total swap file pages).## If you use a lot of small objects, use a page size of 64 or 32 bytes.# If you use a lot of big objects, use a bigger page size.# If unsure, use the default # 设置虚拟内存的页大小,如果你的value值比较大,比如说你要在value中放置博客、# 新闻之类的所有文章内容,就设大一点,如果要放置的都是很小的内容,那就设小一点vm-page-size 32 23、vm-pages123456789101112131415# Number of total memory pages in the swap file.# Given that the page table (a bitmap of free/used pages) is taken in memory,# every 8 pages on disk will consume 1 byte of RAM.## The total swap size is vm-page-size * vm-pages## With the default of 32-bytes memory pages and 134217728 pages Redis will# use a 4 GB swap file, that will use 16 MB of RAM for the page table.## It's better to use the smallest acceptable value for your application,# but the default is large in order to work in most conditions.# 设置交换文件的总的 page 数量,# 需要注意的是,page table信息会放在物理内存中,每8个page就会占据RAM中的1个byte。# 总的虚拟内存大小 = vm-page-size * vm-pagesvm-pages 134217728 24、vm-max-threads1234567891011# Max number of VM I/O threads running at the same time.# This threads are used to read/write data from/to swap file, since they# also encode and decode objects from disk to memory or the reverse, a bigger# number of threads can help with big objects even if they can't help with# I/O itself as the physical device may not be able to couple with many# reads/writes operations at the same time.## The special value of 0 turn off threaded I/O and enables the blocking# Virtual Memory implementation.# 设置 VM IO 同时使用的线程数量。vm-max-threads 4 25、hash-max-zipmap123456789# Hashes are encoded in a special way (much more memory efficient) when they# have at max a given numer of elements, and the biggest element does not# exceed a given threshold. You can configure this limits with the following# configuration directives.# redis 2.0 中引入了 hash 数据结构。 # hash中包含超过指定元素个数并且最大的元素当没有超过临界时,# hash 将以zipmap(又称为 small hash大大减少内存使用)来存储,这里可以设置这两个临界值hash-max-zipmap-entries 512hash-max-zipmap-value 64 26、activerehashing123456789101112131415161718192021222324# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in# order to help rehashing the main Redis hash table (the one mapping top-level# keys to values). The hash table implementation redis uses (see dict.c)# performs a lazy rehashing: the more operation you run into an hash table# that is rhashing, the more rehashing \"steps\" are performed, so if the# server is idle the rehashing is never complete and some more memory is used# by the hash table.# # The default is to use this millisecond 10 times every second in order to# active rehashing the main dictionaries, freeing memory when possible.## If unsure:# use \"activerehashing no\" if you have hard latency requirements and it is# not a good thing in your environment that Redis can reply form time to time# to queries with 2 milliseconds delay.## use \"activerehashing yes\" if you don't have such hard requirements but# want to free memory asap when possible.# 开启之后, redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash,# 可以降低内存的使用。# 当你的使用场景中,有非常严格的实时性需要,不能够接受Redis时不时的对请求有2毫秒的延迟的话,# 把这项配置为 no。# 如果没有这么严格的实时性要求,可以设置为 yes,以便能够尽可能快的释放内存activerehashing yes","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yuechang.github.io/tags/redis/"}]},{"title":"Redis的安装","slug":"Redis的安装","date":"2015-07-07T13:50:01.000Z","updated":"2015-09-16T14:25:44.000Z","comments":true,"path":"2015/07/07/Redis的安装/","link":"","permalink":"http://yuechang.github.io/2015/07/07/Redis的安装/","excerpt":"","text":"redis是比较流行的NOSQL数据库之一，下面来记录下redis的安装过程： 1. 安装环境介绍：Redis版本：redis-3.0.1Linux版本：Red Hat Enterprise Linux Workstation release 7.0 (Maipo) 2. 下载所需Redis文件在http://redis.io下载最新的稳定版本。这里下载的是redis-3.0.1.tar.gz 3. 将所下载文件放入Linux系统中通过Xmanager中Xftp工具连接到对应机器，将redis-3.0.1.tar.gz放到/redis文件夹下，如下图： 4. 将压缩文件解压并编译解压：tar zxvf redis-3.0.1.tar.gz编译：make 5. 启动redis服务器切换到src目录下，并通过./redis-server /redis/redis-3.0.1/redis.conf启动 服务器 6. 验证服务器是否成功启动通过./redis-cli -h 192.168.161.252 -p 6379连接到客户端，并设置相关值来验证服务器是否成功启动 7. 其他相关命令参考查看redis相关线程：ps -ef|grep redis关闭redis服务：./redis-cli -h 192.168.153.138 -p 6379查看redis信息：./redis-cli -h 192.168.153.138 -p 6379 info","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yuechang.github.io/tags/redis/"}]},{"title":"克罗地亚狂想曲","slug":"克罗地亚狂想曲","date":"2015-05-31T13:35:08.000Z","updated":"2015-09-16T13:40:12.000Z","comments":true,"path":"2015/05/31/克罗地亚狂想曲/","link":"","permalink":"http://yuechang.github.io/2015/05/31/克罗地亚狂想曲/","excerpt":"","text":"马克西姆-克罗地亚狂想曲乐曲建构了一个让人印象深刻的和弦的三音主题。克罗地亚战后，尚未散去的硝烟在空气中弥散着。天空有些低沉，专辑封面专辑封面不知是雨前的预兆，还是硝烟的弥漫，云朵在天空中呈现出一种忧郁的灰色。倒塌的墙壁让凌乱的碎石铺了一地，尘埃在空气里飘摇，最终落定，回归泥土。在战火摧残后的断垣残壁中，开着一朵不知名的白色小花。克罗地亚战后，尚未散去的硝烟在空气中弥散着。天空有些低沉，不知说不出名字的小白花，在风里微微的摇曳。它看着人们来来去去，看着战车，坦克威胁着要摧毁它的根与土，也看着鸟儿偶尔慌张驻足。想在人烟散尽的石缝中找寻一点面包屑……只有夜晚来临时，它才看得到平静。在这块紧邻着亚得里亚海的土地上，这些年星光特别璀璨，或许是霓虹与车水马龙都已散去的缘故，这样的夜里，有悲伤，也有着无声的凄凉。曲子和弦美到了极至，每每听到这首曲子时，心中总是泛起淡淡的伤感和坚强。因为对这支曲子有着特殊的情感,现在却越发不敢去弹它,怕它勾起回忆,但是这也是我向上帝所祈求的.马克西姆所演奏的另一首钢琴曲：出埃及记， 描述的也是一段战争与新生，讲述犹太人在血与火之中重建犹太国家以色列的故事，悲壮宏大，让我不由得想起一个东西，那是一个不带任何感情的杀戮机器，大家通常称之为：历史。基于动物性中的种种阴暗面，人在不停的互相杀戮，从未止息，那些并不厚重的历史书，挟裹的是几千年的鲜血。有人曾经预言：人类最终的走向是自我毁灭，所有的一切都将会毁灭在自己手中。或许是，不过在那些阴暗和鲜血的另一面，是人性中光辉不屈的一面：无论是遗忘还是铭记，总会继续坚强的生存下去，带着伤痕，在被摧残的大地上夺取新生一如克罗地亚废墟上的那朵白色小花。","categories":[],"tags":[]},{"title":"做一个内心强大的人","slug":"做一个内心强大的人","date":"2015-05-19T14:42:31.000Z","updated":"2015-07-24T14:38:06.000Z","comments":true,"path":"2015/05/19/做一个内心强大的人/","link":"","permalink":"http://yuechang.github.io/2015/05/19/做一个内心强大的人/","excerpt":"","text":"二百年前丹麦思想家克尔凯郭尔一生一贫如洗，生命也很短暂，但是，他内心强大，一生充满快乐。像这样的人的幸福，是一般人所难以理解的。像这样内心强大的人，其实是精神贵族。 现代社会，每个人都面对强大的社会压力，这其中，有来自事业的压力，身体健康的压力，亲人朋友给的压力。很多人无法承受一点委屈，当被人误解和冤枉时，往往感觉心理很受伤。而其实一个真正内心强大的人，是没有人能伤害你的。因为，内心强大的人，他不活在别人的眼光里。即使全国的人以他为敌，即使全世界的人误解了他，孤立了他，他也能够淡然而坚定地生活。内心强大的人，在真理与真相面前，他就是敢于成为国民之敌的人，在这个时候，那个最孤独的人，就是世界上最有力量的人，成为千夫所指的人，也就是真正有思想的人，这样的人的内心世界就到了强大之极的地步。 但请不要误解，一个拥有强大内心的男人，平时并非是强势的咄咄逼人的，相反他可能是温柔的、微笑的、韧性的、不紧不慢的、沉着而淡定的。拥有强大内心的男人，他们反而更温柔，更和蔼。内心强大是心中的安定与平静。强大，不是霸道，不是要将别人的所有占为己有，恰恰相反，内心的强大带给我们的是宽容和谦让。正是因为内心的安定与平静，我们才明白自己真正需要什么，才明白如何才能得到快乐。 每个人都会受伤害，因为人生没有绝对的公平，而是相对公平的。当在一个天平秤上，你得到的越多，也必须比别人承受得更多。同样的伤害，区别在于，内心强大的人更懂得安慰自己，并总是对未来充满希望。当我们内心强大到可以战胜一切恐惧与悲观的时候，其实已经无所谓希望了，因为我们在哪儿，希望就在哪儿。所以，世界上总有这么一种人，似乎特别得到老天爷的偏爱。他总是有自己的理想，并且总是努力去做，最重要的是，老天爷每一次都会帮他取得成功。是不是很令人羡慕？ 其实，我一直以为，与其说每个人有自己的命运，人生各不相同，倒不如说我们自己打造了自己别样的人生。内心的强大，是人生目标的清晰。因为清晰，所以我们可以坚定地走下去；因为清晰，我们才不会跌跌撞撞却不知身在何方；因为清晰，我们才可以知道什么是对的，什么是错的。不要用世俗的标准去衡量它们。不要给他们标记上“对”或者“错”。我们必须看清楚它们究竟是什么。如果听到自己的心说“我要挣大钱”，也不必觉得难以启齿。在道德标准范围内，任何想法都完全可以心安理得。我们应该做的，只是让他们变得明朗化。不要让内心积聚太多的冲突。 其实，在人生的任何时候都不要怕重头再来，每一个看似低的起点，都是通往更高峰的必经之路。人人都有他的难处，何必强求于人。痛苦与快乐不在于外在物质的有无，而在自己心境的修养。无论做什么，记得是为自己而做，那就毫无怨言。面对困境，也不要悲观厌世。我们也许会暂时变得一无所有。空空的手心并不意味着空空的内心。卷土重来的英雄故事我们听得太多了。一切只关乎内心的强大。我们可以苦闷、可以失落，但是不可以内心空虚。必须明白，环境是什么并不重要，记得让自己的内心强大起来。让自己更平和一点，更豁达一点，对于身边的过错，让自己更宽容一点。 内心强大的人不失眠，不焦虑，不急躁，随时随地作人生中最坏的打算，往最好处追求。一切灾难与痛苦，都早在他的生命中思量过了，甚至丰富真切地体验过了。所以，不管做任何事，记住，先建设一个强大的内心。我不依靠任何人给我幸福，任何人的爱对我的人生只是锦上添花，而不是生命之源。这爱来了，这爱存在，我很快乐；这爱没了，这爱切断了，我会伤感，却不会绝望。因为，我始终知道，幸福和快乐，是自己给予自己的","categories":[],"tags":[]},{"title":"二十岁出头的时候，你一无所有，你拥有一切","slug":"二十岁出头的时候，你一无所有，你拥有一切","date":"2015-05-18T15:05:54.000Z","updated":"2015-05-18T15:19:04.000Z","comments":true,"path":"2015/05/18/二十岁出头的时候，你一无所有，你拥有一切/","link":"","permalink":"http://yuechang.github.io/2015/05/18/二十岁出头的时候，你一无所有，你拥有一切/","excerpt":"","text":"二十岁出头的时候，你一无所有，你拥有一切。说明：此文虽然是转载的，但是我依旧争取上首页，传递正能量。希望管理能让它在首页多停留一会献给那些正在奋斗的人们！ 一篇治愈系的励志文，让我想到一句话，青春就是明明一无所有，却仍然相信有一天世界会在你脚下。 （1）嘴上说说的人生&nbsp;那年我在离家的时候一个劲地往自己的硬盘里塞《灌篮高手》，我妈一副嗤之以鼻的表情看着我，似乎是在说：“这么大的人了居然还这么喜欢看动漫。”我不知道怎么回应她，只好耸耸肩，因为我实在无法对我亲爱的娘亲说明这部动漫对我的意义。你知道，有些歌有些东西就是有那种力量。哪怕它在你的手机里藏了好几年，哪怕它早就过了黄金期，哪怕越来越少的人会提起它。你就是知道，当你一听起这首歌的时候，当你一看起那些漫画的时候，你就会想到以前的自己，你就会获得一种莫名的力量。这种力量能够让你感受到自己的节奏，让你以跟世界不同的方式独自运转着，你能听到自己。比如那首永远的butterfly和直到世界的尽头，它们比记忆更可靠。在记忆里最让你印象深刻的，一定是当年的你自己。因为只有在这个时候才发现，在你嚷嚷着“时间变化太快”的同时，在那些所谓的“物是人非”里，变化最多的人是你自己。我不知道怎么样的人生是最可怕的，但是我知道当你有一天你回头看，当你发现你曾经所说的一切，你曾经信誓旦旦的一切变成说说而已的时候，一定不会好受到哪里去。好像人一长大，就会把很多东西给弄丢了。比如那些简单却能让自己充实开心一天的东西，比如让自己肆意哭和笑的能力，还有那些曾经一起结伴同行的人。最可怕的不是弄丢了这些东西，而是你变得心安理得。你开始安慰自己，这就是成长，这就是我们最终会变成的样子。你只是找了个借口继续这样的生活，对以前的自己嗤之以鼻。只是每当你听起以前的歌的时候，或者你看到某个人在他自己的道路坚持下去的时候，你都会像被自己扇了一个大嘴巴。看着别人的努力羡慕一下然后转身回去过自己的生活的你，又凭什么去过自己想要的人生？(2)努力，是为了给自己交代&nbsp;曾经跟好友为了商谈一个项目去北京，对方是一个标准的八零后，北漂。这是他飘着的第三年，伴随着他一直没有改变的直来直往的性格。这是他第三年换的第三份工作，一直没有安稳过。他说：“这些年我看过了很多人，有些人不用做什么就可以有很好的前景，有些人拼死拼活还是没有办法在这个城市里生存。”在沪江上认识的一个小姑娘，她曾经差点为了她的男朋友去国外陪读一年，可是后来他们偏偏分手了。后来她决定一个人去上海，最苦逼的时候连饭都没得吃，就拿着几个包子躲在地铁站里，不知道去哪里。曾经我总是无法理解，明明回到爸妈身边工作更好，也可以陪在爸妈身边，何必在大城市里摸爬滚打，还得不到一个很好的结果。就像我曾经写过的那个在动车里哭泣的姑娘，到最后没办法了只能回家。我曾觉得这样太不值得，然而当我有一天面临选择的时候，我终于明白他们做决定的时候是一个什么样的心情。那个北漂着的哥们说过，哪怕自己奋斗了一辈子也是个屌丝，那么至少这样子自己不会再有借口了，不会在老的时候悔不该当初。你说值得么？我觉得值得。虽然我直来直往的性格给自己带来了很多麻烦，但这就是我，这就是我存在的方式。其实所有漂泊的人，不过是为了有一天能够不再漂泊，能用自己的力量撑起身后的家人和自己爱的人。你觉得最好的生活状态是什么？我觉得最好的生活状态莫过于，在你的青春年纪傻逼地为了理想坚持过，最后回到平淡用现实的方法让自己生活下去。能实现梦想自然是最好，但没能实现自己的梦想那也没有什么可惜的。成长的第一步就是接受这个世界的多样性，认识到现实的不美好，然后还是决定要坚持最初的坚持。小时候我总嚷嚷着，努力是了改变世界，然而现在的我会觉得，有些人努力只是为了变成一个普通人，有些人努力只是为了给自己交代，也许我们始终都只是一个小人物，但这并不妨碍我们选择用什么样的方式活下去。窃以为，那些在看透了生活的无奈之后，还是选择不敷衍不抱怨不自卑依旧热爱生活依旧努力做好身边的事的人，努力便是他们对自己的交代。就像我曾经跟李婧讨论去哪里工作的时候，最后我们得出结论，其实无论在哪个城市存活都不容易，但无论过成什么样子，都要自己承担的起。我有勇气做选择，自然要有本事承担地起后果。（3）只有行动，才能解除你所有的不安。&nbsp;你说你想要当自由撰稿人，可从不见你努力写稿；你说你想考研，可从不见你背词做题；你看到学霸出没于是嗤之以鼻说这样活着没意思，你看到有人旅行又不屑一顾说这只是从大流。我开始怀疑你挂在嘴边的是不是逃避现实的借口，我开始怀疑你是不是在一遍遍逃避和自我安慰中变得惴惴不安。于是你慢慢屈服于自己的欲望。明明在几年以后能有更好的生活，却一定要在现在买上最新的包。每个人都开始想要达到一定的社会地位和物质条件，似乎结果才是最重要的。然而，你有没有想过，你所谓的所有努力，是为了满足你的欲望还是真的追求上进？就像汪峰的歌里面说的：“少人走着却困在原地，多少人活着却如同死去，多少人爱着却好似分离，多少人笑着却满含泪滴。”终于有一天，你发现你取得了当时所要的结果，可是在那之后，却再也不知道怎么继续了。二十岁出头的时候，请把自己摆在二十岁出头的位置上。你没有理由也没能力去拥有一个四十岁的人拥有的阅历和财富，你除了手头的青春你一无所有，但就是你手头这为数不多的东西，能决定你是一个怎么样的人。我不知道这个世界上是不是真的有所谓的安全感，还是因为每个人都说自己没有安全感，所以你也觉得自己没有安全感。我对安全感的定义只有两个：一是别人给你的能量总有一天会消失的，只有自己给自己的安全感最可靠，只有行动才会给你带来安全感；二是永远要记得，不管你是一个什么样的德行，你都是你父母的安全感。所以当你觉得不安的时候，请想一想身后的父母，想想他们正在为你打拼；请想一想自己的初衷，然后抬起头继续倔强地走下去。唯有行动，才能解除你所有的不安。（4）有梦想，不抱怨。&nbsp;时间一天天过去，我们终会因我们的努力或堕落变得丰富或苍白。有时间我就每天花两小时看书，没时间就睡前看二十分钟，周末的话可以看完整本书。做论题做一遍做不好我就做两遍，文稿要求我写一万字我就写将近两万字然后删。写出一篇好文是运气，如果一个人一直在写的话，那就是靠努力。更多时候，世界对你的态度取决于你对世界的态度，没什么好抱怨的。为什么我们一再打击还要继续向前走？为什么明明很失望了我们也不愿意放弃一个人和一个理想？所有人，所有人还坚持向前走着，只是因为他想要向前走着，只是因为他还不愿意像世界投降。也许没有人跟你完全一样，也没有人可以时时刻刻地陪在你身边，也许我们很久以后回过头来看，会连现在的珍惜的人的样貌都记不清。可是我最大的幸运却是，即便如此，还是有人愿意在有限的时间里用心地陪我走过这一段。愿意跟我一起为了梦想努力，经历那些孤单流离。这样一想，人生也还真是不错呢。当你看书看到头痛两眼通红的时候；当你按着遥控器不停转台的时候；当你翻着通讯录不知道打给谁的时候；当你独自穿越人群看着两岸灯火找不到归属感的时候；你就应该听起一首歌，看起一本书，想想自己最初的坚持和你站在这个地方的理由，然后抬起头勇敢地走下去了。这首歌有一句话是：“是否找个理由随波逐流 或是勇敢前行挣脱牢笼 ”，我想，你知道答案。你现在一无所有，但你却拥有一切，因为你还有牛逼的梦想。只要路是自己选的，就不怕走远，生活总会留点什么给对它抱有信心的人的。","categories":[],"tags":[]},{"title":"Why String is immutable in Java","slug":"why-string-is-immutable-in-java","date":"2014-12-19T14:05:16.000Z","updated":"2015-09-16T14:25:00.000Z","comments":true,"path":"2014/12/19/why-string-is-immutable-in-java/","link":"","permalink":"http://yuechang.github.io/2014/12/19/why-string-is-immutable-in-java/","excerpt":"","text":"String is an immutable class in Java. An immutable class is simply a class whose instances cannot be modified. All information in an instance is initialized when the instance is created and the information can not be modified. There are many advantages of immutable classes. This article summarizes why String is designed to be immutable. A good answer depends on deep understanding of memory, synchronization, data structures, etc. 1. Requirement of String PoolString pool (String intern pool) is a special storage area in Method Area. When a string is created and if the string already exists in the pool, the reference of the existing string will be returned, instead of creating a new object and returning its reference. The following code will create only one string object in the heap. 12String string1 = \"abcd\";String string2 = \"abcd\"; Here is how it looks: If string is not immutable, changing the string with one reference will lead to the wrong value for the other references. 2. Caching HashcodeThe hashcode of string is frequently used in Java. For example, in a HashMap. Being immutable guarantees that hashcode will always the same, so that it can be cashed without worrying the changes.That means, there is no need to calculate hashcode every time it is used. This is more efficient. In String class, it has the following code:1private int hash;//this is used to cache hash code. 3. Facilitating the Use of Other ObjectsTo make this concrete, consider the following program:1234567HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();set.add(new String(\"a\"));set.add(new String(\"b\"));set.add(new String(\"c\")); for(String a: set) a.value = \"a\"; In this example, if String is mutable, it’s value can be changed which would violate the design of set (set contains unduplicated elements). This example is designed for simplicity sake, in the real String class there is no value field. 4. SecurityString is widely used as parameter for many java classes, e.g. network connection, opening files, etc. Were String not immutable, a connection or file would be changed and lead to serious security threat. The method thought it was connecting to one machine, but was not. Mutable strings could cause security problem in Reflection too, as the parameters are strings. Here is a code example:1234567boolean connect(string s)&#123; if (!isSecure(s)) &#123; throw new SecurityException(); &#125; //here will cause problem, if s is changed before this by using other references. causeProblem(s);&#125; 5. Immutable objects are naturally thread-safeBecause immutable objects can not be changed, they can be shared among multiple threads freely. This eliminate the requirements of doing synchronization. In summary, String is designed to be immutable for the sake of efficiency and security. This is also the reason why immutable classes are preferred in general. 参考文件：http://www.programcreek.com/1:http://www.programcreek.com/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yuechang.github.io/tags/java/"}]},{"title":"Diagram to show Java String's Immutability","slug":"diagram-to-show-java-strings-immutability","date":"2014-12-18T14:29:41.000Z","updated":"2015-09-16T14:25:22.000Z","comments":true,"path":"2014/12/18/diagram-to-show-java-strings-immutability/","link":"","permalink":"http://yuechang.github.io/2014/12/18/diagram-to-show-java-strings-immutability/","excerpt":"","text":"Here are a set of diagrams to illustrate Java String’s immutability. 1. Declare a string1String s = \"abcd\"; s stores the reference of the string object. The arrow below should be interpreted as “store reference of”. 2. Assign one string variable to another string variable1String s2 = s; s2 stores the same reference value, since it is the same string object. 3. Concat string1s = s.concat(\"ef\"); s now stores the reference of newly created string object. SummaryOnce a string is created in memory(heap), it can not be changed. We should note that all methods of String do not change the string itself, but rather return a new String. If we need a string that can be modified, we will need StringBuffer or StringBuilder. Otherwise, there would be a lot of time wasted for Garbage Collection, since each time a new String is created. Here is an example of StringBuilder usage. 参考文件：[http://www.programcreek.com/][1][1]:http://www.programcreek.com/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yuechang.github.io/tags/java/"}]},{"title":"每天问自己五件事","slug":"每天问自己五件事","date":"2014-12-14T14:35:50.000Z","updated":"2015-09-16T13:54:20.000Z","comments":true,"path":"2014/12/14/每天问自己五件事/","link":"","permalink":"http://yuechang.github.io/2014/12/14/每天问自己五件事/","excerpt":"","text":"![][1][1]:http://7s1reu.com1.z0.glb.clouddn.com/test伴着梦想入睡，带着目标醒来.jpg 1. How happy am I overall, today, out of 10?我今天有多开心，10分能打几分？Take into account all areas of your life when you do this. Whatever your number is, be honest about it with yourself. Then you can get real about what you can do to increase it. 回答这个问题时，你要考虑到生活里的各个方面。不管你得了几分，坦诚面对吧。之后你就能清楚自己能做些什么来提高开心指数。 2. What type of life do I want to lead?我想要过什么样的生活？Think about your life 10 years from now. Are you satisfied with your life if it is to continue exactly as it currently is? Are you content with your relationships, work, health? Picture the ideal life you could be living.How is it different? Visualizing helps us understand what it is that we can be doing differently now. 想想你10年之后的生活。如果那时你的生活和现在一模一样，你会觉得满意吗？你对你的爱人、工作以及健康状况满意吗？想象一下你理想中的生活状态。和现在有什么不同？想象让我们知道自己现在需要做出什么改变。 3. What does success look like to me?我眼里的成功是什么？For some people it is becoming an expert in their industry. For others it is taking one year off in every five to seven to travel. For some it is raising a healthy and tight-knit family. Be clear on what it looks like to you and don’t be swayed by others visions for themselves. Your life is your path to honor and actualize. 对有些人来说，成功意味着变成他们所在领域的专家，有些人觉得成功是每隔5年至7年就给自己放一年的假来旅游，有些人眼里的成功就是维持健康团结的家庭生活。明确自己眼里的成功，不要被别人的意见左右。生活就是实现自己眼里的荣耀。 4. What brings me joy?什么事情会让我快乐？Is it writing, teaching, singing, volunteering, dancing? Whatever it is, make time for it! 是写作、教书、唱歌、当志愿者还是跳舞？不管是什么，为这些事情留出时间！ 5. What can I do in the next two weeks to bring more joy, passion and purpose to my life?在未来2周里，我能做些什么来给我的生活增添更多的欢乐、激情以及目标？This is the killer part right here. All of the above is important but it won’t impact your life unless you take action. Start small. Write one blog. Take one dance class. Perhaps speak to a friend in Europe about a potential meet over the next few months. You know what it is that will generate excitement and happiness in your life. Don’t put it off! 最重要的部分来了。上述问题都很重要，但是只有你采取行动，它们才能改变你的生活！从小事开始吧。写一篇博客，参加一节舞蹈课，或者和你欧洲的朋友聊聊以后几个月里有没有可能见面。你知道做什么能够给你的生活带来刺激和快乐的。不要拖延!！ The answers are within us. We have everything we need to create the lives we want. Getting clear is the starting point. An old proverb says, “The best time to plant a tree is 20 years ago. The second-best time is now.” Get busy now sowing the seeds of the life you want to flourish over the coming years. 答案就在我们心中。我们完全有能力来创造自己想要的生活。明确方向是第一步。老话说：“种一棵树的最佳时机是20年前，再就是现在。” 现在就动起来，为你将来茂盛的生活大树播下种子。","categories":[],"tags":[]},{"title":"新的开始","slug":"新的开始","date":"2014-11-27T06:23:50.000Z","updated":"2015-09-16T13:53:08.000Z","comments":true,"path":"2014/11/27/新的开始/","link":"","permalink":"http://yuechang.github.io/2014/11/27/新的开始/","excerpt":"","text":"这是新的开始，我用hexo创建了第一篇文章。 通过下面的命令，就可以创建新文章12D:\\workspace\\javascript\\nodejs-hexo&gt;hexo new 新的开始[info] File created at D:\\workspace\\javascript\\nodejs-hexo\\source\\_posts\\新的开始.md 感觉非常好。","categories":[],"tags":[]}]}